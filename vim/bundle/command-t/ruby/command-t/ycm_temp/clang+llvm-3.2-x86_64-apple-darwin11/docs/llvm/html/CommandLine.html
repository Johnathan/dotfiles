

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>CommandLine 2.0 Library Manual &mdash; LLVM 3.2 documentation</title>
    
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="LLVM 3.2 documentation" href="index.html" />
    <link rel="up" title="Programming Documentation" href="programming.html" />
    <link rel="next" title="Architecture &amp; Platform Information for Compiler Writers" href="CompilerWriterInfo.html" />
    <link rel="prev" title="LLVM Coding Standards" href="CodingStandards.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="CompilerWriterInfo.html" title="Architecture &amp; Platform Information for Compiler Writers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="CodingStandards.html" title="LLVM Coding Standards"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li><a href="programming.html" accesskey="U">Programming Documentation</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">CommandLine 2.0 Library Manual</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#quick-start-guide">Quick Start Guide</a><ul>
<li><a class="reference internal" href="#boolean-arguments">Boolean Arguments</a></li>
<li><a class="reference internal" href="#argument-aliases">Argument Aliases</a></li>
<li><a class="reference internal" href="#selecting-an-alternative-from-a-set-of-possibilities">Selecting an alternative from a set of possibilities</a></li>
<li><a class="reference internal" href="#named-alternatives">Named Alternatives</a></li>
<li><a class="reference internal" href="#parsing-a-list-of-options">Parsing a list of options</a></li>
<li><a class="reference internal" href="#collecting-options-as-a-set-of-flags">Collecting options as a set of flags</a></li>
<li><a class="reference internal" href="#adding-freeform-text-to-help-output">Adding freeform text to help output</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-guide">Reference Guide</a><ul>
<li><a class="reference internal" href="#positional-options">Positional Arguments</a><ul>
<li><a class="reference internal" href="#specifying-positional-options-with-hyphens">Specifying positional options with hyphens</a></li>
<li><a class="reference internal" href="#determining-absolute-position-with-getposition">Determining absolute position with getPosition()</a></li>
<li><a class="reference internal" href="#the-cl-consumeafter-modifier">The <tt class="docutils literal"><span class="pre">cl::ConsumeAfter</span></tt> modifier</a></li>
</ul>
</li>
<li><a class="reference internal" href="#internal-vs-external-storage">Internal vs External Storage</a></li>
<li><a class="reference internal" href="#option-attributes">Option Attributes</a></li>
<li><a class="reference internal" href="#option-modifiers">Option Modifiers</a><ul>
<li><a class="reference internal" href="#hiding-an-option-from-help-output">Hiding an option from <tt class="docutils literal"><span class="pre">-help</span></tt> output</a></li>
<li><a class="reference internal" href="#controlling-the-number-of-occurrences-required-and-allowed">Controlling the number of occurrences required and allowed</a></li>
<li><a class="reference internal" href="#controlling-whether-or-not-a-value-must-be-specified">Controlling whether or not a value must be specified</a></li>
<li><a class="reference internal" href="#controlling-other-formatting-options">Controlling other formatting options</a></li>
<li><a class="reference internal" href="#miscellaneous-option-modifiers">Miscellaneous option modifiers</a></li>
<li><a class="reference internal" href="#response-files">Response files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#top-level-classes-and-functions">Top-Level Classes and Functions</a><ul>
<li><a class="reference internal" href="#the-cl-parsecommandlineoptions-function">The <tt class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></tt> function</a></li>
<li><a class="reference internal" href="#the-cl-parseenvironmentoptions-function">The <tt class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></tt> function</a></li>
<li><a class="reference internal" href="#the-cl-setversionprinter-function">The <tt class="docutils literal"><span class="pre">cl::SetVersionPrinter</span></tt> function</a></li>
<li><a class="reference internal" href="#the-cl-opt-class">The <tt class="docutils literal"><span class="pre">cl::opt</span></tt> class</a></li>
<li><a class="reference internal" href="#the-cl-list-class">The <tt class="docutils literal"><span class="pre">cl::list</span></tt> class</a></li>
<li><a class="reference internal" href="#the-cl-bits-class">The <tt class="docutils literal"><span class="pre">cl::bits</span></tt> class</a></li>
<li><a class="reference internal" href="#the-cl-alias-class">The <tt class="docutils literal"><span class="pre">cl::alias</span></tt> class</a></li>
<li><a class="reference internal" href="#the-cl-extrahelp-class">The <tt class="docutils literal"><span class="pre">cl::extrahelp</span></tt> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#builtin-parsers">Builtin parsers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extending-the-library">Extension Guide</a><ul>
<li><a class="reference internal" href="#writing-a-custom-parser">Writing a custom parser</a></li>
<li><a class="reference internal" href="#exploiting-external-storage">Exploiting external storage</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="CodingStandards.html"
                        title="previous chapter">LLVM Coding Standards</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="CompilerWriterInfo.html"
                        title="next chapter">Architecture &amp; Platform Information for Compiler Writers</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/CommandLine.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="commandline-2-0-library-manual">
<span id="commandline"></span><h1>CommandLine 2.0 Library Manual<a class="headerlink" href="#commandline-2-0-library-manual" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes the CommandLine argument processing library.  It will
show you how to use it, and what it can do.  The CommandLine library uses a
declarative approach to specifying the command line options that your program
takes.  By default, these options declarations implicitly hold the value parsed
for the option declared (of course this <a class="reference internal" href="#can-be-changed">can be changed</a>).</p>
<p>Although there are a <strong>lot</strong> of command line argument parsing libraries out
there in many different languages, none of them fit well with what I needed.  By
looking at the features and problems of other libraries, I designed the
CommandLine library to have the following features:</p>
<ol class="arabic simple">
<li>Speed: The CommandLine library is very quick and uses little resources.  The
parsing time of the library is directly proportional to the number of
arguments parsed, not the number of options recognized.  Additionally,
command line argument values are captured transparently into user defined
global variables, which can be accessed like any other variable (and with the
same performance).</li>
<li>Type Safe: As a user of CommandLine, you don&#8217;t have to worry about
remembering the type of arguments that you want (is it an int?  a string? a
bool? an enum?) and keep casting it around.  Not only does this help prevent
error prone constructs, it also leads to dramatically cleaner source code.</li>
<li>No subclasses required: To use CommandLine, you instantiate variables that
correspond to the arguments that you would like to capture, you don&#8217;t
subclass a parser.  This means that you don&#8217;t have to write <strong>any</strong>
boilerplate code.</li>
<li>Globally accessible: Libraries can specify command line arguments that are
automatically enabled in any tool that links to the library.  This is
possible because the application doesn&#8217;t have to keep a list of arguments to
pass to the parser.  This also makes supporting <a class="reference internal" href="#dynamically-loaded-options">dynamically loaded options</a>
trivial.</li>
<li>Cleaner: CommandLine supports enum and other types directly, meaning that
there is less error and more security built into the library.  You don&#8217;t have
to worry about whether your integral command line argument accidentally got
assigned a value that is not valid for your enum type.</li>
<li>Powerful: The CommandLine library supports many different types of arguments,
from simple <a class="reference internal" href="#boolean-flags">boolean flags</a> to <a class="reference internal" href="#scalars-arguments">scalars arguments</a> (<a class="reference internal" href="#strings">strings</a>,
<a class="reference internal" href="#integers">integers</a>, <a class="reference internal" href="#enums">enums</a>, <a class="reference internal" href="#doubles">doubles</a>), to <a class="reference internal" href="#lists-of-arguments">lists of arguments</a>.  This is
possible because CommandLine is...</li>
<li>Extensible: It is very simple to add a new argument type to CommandLine.
Simply specify the parser that you want to use with the command line option
when you declare it. <a class="reference internal" href="#custom-parsers">Custom parsers</a> are no problem.</li>
<li>Labor Saving: The CommandLine library cuts down on the amount of grunt work
that you, the user, have to do.  For example, it automatically provides a
<tt class="docutils literal"><span class="pre">-help</span></tt> option that shows the available command line options for your tool.
Additionally, it does most of the basic correctness checking for you.</li>
<li>Capable: The CommandLine library can handle lots of different forms of
options often found in real programs.  For example, <a class="reference internal" href="#positional">positional</a> arguments,
<tt class="docutils literal"><span class="pre">ls</span></tt> style <a class="reference internal" href="#grouping">grouping</a> options (to allow processing &#8216;<tt class="docutils literal"><span class="pre">ls</span> <span class="pre">-lad</span></tt>&#8216;
naturally), <tt class="docutils literal"><span class="pre">ld</span></tt> style <a class="reference internal" href="#prefix">prefix</a> options (to parse &#8216;<tt class="docutils literal"><span class="pre">-lmalloc</span>
<span class="pre">-L/usr/lib</span></tt>&#8216;), and interpreter style options.</li>
</ol>
<p>This document will hopefully let you jump in and start using CommandLine in your
utility quickly and painlessly.  Additionally it should be a simple reference
manual to figure out how stuff works.  If it is failing in some area (or you
want an extension to the library), nag the author, <a class="reference external" href="mailto:sabre&#37;&#52;&#48;nondot&#46;org">Chris
Lattner</a>.</p>
</div>
<div class="section" id="quick-start-guide">
<h2>Quick Start Guide<a class="headerlink" href="#quick-start-guide" title="Permalink to this headline">¶</a></h2>
<p>This section of the manual runs through a simple CommandLine&#8217;ification of a
basic compiler tool.  This is intended to show you how to jump into using the
CommandLine library in your own program, and show you some of the cool things it
can do.</p>
<p>To start out, you need to include the CommandLine header file into your program:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>
</pre></div>
</div>
<p>Additionally, you need to add this as the first line of your main program:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">ParseCommandLineOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>... which actually parses the arguments and fills in the variable declarations.</p>
<p>Now that you are ready to support command line arguments, we need to tell the
system which ones we want, and what type of arguments they are.  The CommandLine
library uses a declarative syntax to model command line arguments with the
global variable declarations that capture the parsed values.  This means that
for every command line option that you would like to support, there should be a
global variable declaration to capture the result.  For example, in a compiler,
we would like to support the Unix-standard &#8216;<tt class="docutils literal"><span class="pre">-o</span> <span class="pre">&lt;filename&gt;</span></tt>&#8216; option to specify
where to put the output.  With the CommandLine library, this is represented like
this:</p>
<div class="highlight-c++" id="here"><span id="scalars-arguments"></span><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">OutputFilename</span><span class="p">(</span><span class="s">&quot;o&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Specify output filename&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">value_desc</span><span class="p">(</span><span class="s">&quot;filename&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>This declares a global variable &#8220;<tt class="docutils literal"><span class="pre">OutputFilename</span></tt>&#8221; that is used to capture the
result of the &#8220;<tt class="docutils literal"><span class="pre">o</span></tt>&#8221; argument (first parameter).  We specify that this is a
simple scalar option by using the &#8220;<tt class="docutils literal"><span class="pre">cl::opt</span></tt>&#8221; template (as opposed to the
&#8220;<tt class="docutils literal"><span class="pre">cl::list</span></tt>&#8221; template), and tell the CommandLine library that the data
type that we are parsing is a string.</p>
<p>The second and third parameters (which are optional) are used to specify what to
output for the &#8220;<tt class="docutils literal"><span class="pre">-help</span></tt>&#8221; option.  In this case, we get a line that looks like
this:</p>
<div class="highlight-python"><pre>USAGE: compiler [options]

OPTIONS:
  -help             - display available options (-help-hidden for more)
  -o &lt;filename&gt;     - Specify output filename</pre>
</div>
<p>Because we specified that the command line option should parse using the
<tt class="docutils literal"><span class="pre">string</span></tt> data type, the variable declared is automatically usable as a real
string in all contexts that a normal C++ string object may be used.  For
example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">Output</span><span class="p">(</span><span class="n">OutputFilename</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Output</span><span class="p">.</span><span class="n">good</span><span class="p">())</span> <span class="p">...</span>
<span class="p">...</span>
</pre></div>
</div>
<p>There are many different options that you can use to customize the command line
option handling library, but the above example shows the general interface to
these options.  The options can be specified in any order, and are specified
with helper functions like <a class="reference internal" href="#cl-desc">cl::desc(...)</a>, so there are no positional
dependencies to remember.  The available options are discussed in detail in the
<a class="reference internal" href="#reference-guide">Reference Guide</a>.</p>
<p>Continuing the example, we would like to have our compiler take an input
filename as well as an output filename, but we do not want the input filename to
be specified with a hyphen (ie, not <tt class="docutils literal"><span class="pre">-filename.c</span></tt>).  To support this style of
argument, the CommandLine library allows for <a class="reference internal" href="#positional">positional</a> arguments to be
specified for the program.  These positional arguments are filled with command
line parameters that are not in option form.  We use this feature like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">InputFilename</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input file&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>This declaration indicates that the first positional argument should be treated
as the input filename.  Here we use the <a class="reference internal" href="#cl-init">cl::init</a> option to specify an initial
value for the command line option, which is used if the option is not specified
(if you do not specify a <a class="reference internal" href="#cl-init">cl::init</a> modifier for an option, then the default
constructor for the data type is used to initialize the value).  Command line
options default to being optional, so if we would like to require that the user
always specify an input filename, we would add the <a class="reference internal" href="#cl-required">cl::Required</a> flag, and we
could eliminate the <a class="reference internal" href="#cl-init">cl::init</a> modifier, like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">InputFilename</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input file&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">Required</span><span class="p">);</span>
</pre></div>
</div>
<p>Again, the CommandLine library does not require the options to be specified in
any particular order, so the above declaration is equivalent to:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">InputFilename</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">Required</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input file&gt;&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>By simply adding the <a class="reference internal" href="#cl-required">cl::Required</a> flag, the CommandLine library will
automatically issue an error if the argument is not specified, which shifts all
of the command line option verification code out of your application into the
library.  This is just one example of how using flags can alter the default
behaviour of the library, on a per-option basis.  By adding one of the
declarations above, the <tt class="docutils literal"><span class="pre">-help</span></tt> option synopsis is now extended to:</p>
<div class="highlight-python"><pre>USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  -help             - display available options (-help-hidden for more)
  -o &lt;filename&gt;     - Specify output filename</pre>
</div>
<p>... indicating that an input filename is expected.</p>
<div class="section" id="boolean-arguments">
<h3>Boolean Arguments<a class="headerlink" href="#boolean-arguments" title="Permalink to this headline">¶</a></h3>
<p>In addition to input and output filenames, we would like the compiler example to
support three boolean flags: &#8220;<tt class="docutils literal"><span class="pre">-f</span></tt>&#8221; to force writing binary output to a
terminal, &#8220;<tt class="docutils literal"><span class="pre">--quiet</span></tt>&#8221; to enable quiet mode, and &#8220;<tt class="docutils literal"><span class="pre">-q</span></tt>&#8221; for backwards
compatibility with some of our users.  We can support these by declaring options
of boolean type like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Force</span> <span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Enable binary output on terminals&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Quiet</span> <span class="p">(</span><span class="s">&quot;quiet&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Don&#39;t print informational messages&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Quiet2</span><span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Don&#39;t print informational messages&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">);</span>
</pre></div>
</div>
<p>This does what you would expect: it declares three boolean variables
(&#8220;<tt class="docutils literal"><span class="pre">Force</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">Quiet</span></tt>&#8221;, and &#8220;<tt class="docutils literal"><span class="pre">Quiet2</span></tt>&#8221;) to recognize these options.  Note
that the &#8220;<tt class="docutils literal"><span class="pre">-q</span></tt>&#8221; option is specified with the &#8220;<a class="reference internal" href="#cl-hidden">cl::Hidden</a>&#8221; flag.  This
modifier prevents it from being shown by the standard &#8220;<tt class="docutils literal"><span class="pre">-help</span></tt>&#8221; output (note
that it is still shown in the &#8220;<tt class="docutils literal"><span class="pre">-help-hidden</span></tt>&#8221; output).</p>
<p>The CommandLine library uses a <a class="reference internal" href="#different-parser">different parser</a> for different data types.
For example, in the string case, the argument passed to the option is copied
literally into the content of the string variable... we obviously cannot do that
in the boolean case, however, so we must use a smarter parser.  In the case of
the boolean parser, it allows no options (in which case it assigns the value of
true to the variable), or it allows the values &#8220;<tt class="docutils literal"><span class="pre">true</span></tt>&#8221; or &#8220;<tt class="docutils literal"><span class="pre">false</span></tt>&#8221; to be
specified, allowing any of the following inputs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">compiler</span> <span class="o">-</span><span class="n">f</span>          <span class="c"># No value, &#39;Force&#39; == true</span>
<span class="n">compiler</span> <span class="o">-</span><span class="n">f</span><span class="o">=</span><span class="n">true</span>     <span class="c"># Value specified, &#39;Force&#39; == true</span>
<span class="n">compiler</span> <span class="o">-</span><span class="n">f</span><span class="o">=</span><span class="n">TRUE</span>     <span class="c"># Value specified, &#39;Force&#39; == true</span>
<span class="n">compiler</span> <span class="o">-</span><span class="n">f</span><span class="o">=</span><span class="n">FALSE</span>    <span class="c"># Value specified, &#39;Force&#39; == false</span>
</pre></div>
</div>
<p>... you get the idea.  The <a class="reference internal" href="#bool-parser">bool parser</a> just turns the string values into
boolean values, and rejects things like &#8216;<tt class="docutils literal"><span class="pre">compiler</span> <span class="pre">-f=foo</span></tt>&#8216;.  Similarly, the
<a class="reference internal" href="#float">float</a>, <a class="reference internal" href="#double">double</a>, and <a class="reference internal" href="#int">int</a> parsers work like you would expect, using the
&#8216;<tt class="docutils literal"><span class="pre">strtol</span></tt>&#8216; and &#8216;<tt class="docutils literal"><span class="pre">strtod</span></tt>&#8216; C library calls to parse the string value into the
specified data type.</p>
<p>With the declarations above, &#8220;<tt class="docutils literal"><span class="pre">compiler</span> <span class="pre">-help</span></tt>&#8221; emits this:</p>
<div class="highlight-python"><pre>USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  -f     - Enable binary output on terminals
  -o     - Override output filename
  -quiet - Don't print informational messages
  -help  - display available options (-help-hidden for more)</pre>
</div>
<p>and &#8220;<tt class="docutils literal"><span class="pre">compiler</span> <span class="pre">-help-hidden</span></tt>&#8221; prints this:</p>
<div class="highlight-python"><pre>USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  -f     - Enable binary output on terminals
  -o     - Override output filename
  -q     - Don't print informational messages
  -quiet - Don't print informational messages
  -help  - display available options (-help-hidden for more)</pre>
</div>
<p>This brief example has shown you how to use the &#8216;<a class="reference internal" href="#cl-opt">cl::opt</a>&#8216; class to parse
simple scalar command line arguments.  In addition to simple scalar arguments,
the CommandLine library also provides primitives to support CommandLine option
<a class="reference internal" href="#aliases">aliases</a>, and <a class="reference internal" href="#lists">lists</a> of options.</p>
</div>
<div class="section" id="argument-aliases">
<span id="aliases"></span><h3>Argument Aliases<a class="headerlink" href="#argument-aliases" title="Permalink to this headline">¶</a></h3>
<p>So far, the example works well, except for the fact that we need to check the
quiet condition like this now:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Quiet</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Quiet2</span><span class="p">)</span> <span class="n">printInformationalMessage</span><span class="p">(...);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>... which is a real pain!  Instead of defining two values for the same
condition, we can use the &#8220;<a class="reference internal" href="#cl-alias">cl::alias</a>&#8221; class to make the &#8220;<tt class="docutils literal"><span class="pre">-q</span></tt>&#8221; option an
<strong>alias</strong> for the &#8220;<tt class="docutils literal"><span class="pre">-quiet</span></tt>&#8221; option, instead of providing a value itself:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Force</span> <span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Overwrite output files&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Quiet</span> <span class="p">(</span><span class="s">&quot;quiet&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Don&#39;t print informational messages&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">alias</span>     <span class="n">QuietA</span><span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Alias for -quiet&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">aliasopt</span><span class="p">(</span><span class="n">Quiet</span><span class="p">));</span>
</pre></div>
</div>
<p>The third line (which is the only one we modified from above) defines a &#8220;<tt class="docutils literal"><span class="pre">-q</span></tt>&#8221;
alias that updates the &#8220;<tt class="docutils literal"><span class="pre">Quiet</span></tt>&#8221; variable (as specified by the <a class="reference internal" href="#cl-aliasopt">cl::aliasopt</a>
modifier) whenever it is specified.  Because aliases do not hold state, the only
thing the program has to query is the <tt class="docutils literal"><span class="pre">Quiet</span></tt> variable now.  Another nice
feature of aliases is that they automatically hide themselves from the <tt class="docutils literal"><span class="pre">-help</span></tt>
output (although, again, they are still visible in the <tt class="docutils literal"><span class="pre">-help-hidden</span> <span class="pre">output</span></tt>).</p>
<p>Now the application code can simply use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Quiet</span><span class="p">)</span> <span class="n">printInformationalMessage</span><span class="p">(...);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>... which is much nicer!  The &#8220;<a class="reference internal" href="#cl-alias">cl::alias</a>&#8221; can be used to specify an
alternative name for any variable type, and has many uses.</p>
</div>
<div class="section" id="selecting-an-alternative-from-a-set-of-possibilities">
<span id="unnamed-alternatives-using-the-generic-parser"></span><h3>Selecting an alternative from a set of possibilities<a class="headerlink" href="#selecting-an-alternative-from-a-set-of-possibilities" title="Permalink to this headline">¶</a></h3>
<p>So far we have seen how the CommandLine library handles builtin types like
<tt class="docutils literal"><span class="pre">std::string</span></tt>, <tt class="docutils literal"><span class="pre">bool</span></tt> and <tt class="docutils literal"><span class="pre">int</span></tt>, but how does it handle things it doesn&#8217;t
know about, like enums or &#8216;<tt class="docutils literal"><span class="pre">int*</span></tt>&#8216;s?</p>
<p>The answer is that it uses a table-driven generic parser (unless you specify
your own parser, as described in the <a class="reference internal" href="#extension-guide">Extension Guide</a>).  This parser maps
literal strings to whatever type is required, and requires you to tell it what
this mapping should be.</p>
<p>Let&#8217;s say that we would like to add four optimization levels to our optimizer,
using the standard flags &#8220;<tt class="docutils literal"><span class="pre">-g</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">-O0</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">-O1</span></tt>&#8221;, and &#8220;<tt class="docutils literal"><span class="pre">-O2</span></tt>&#8221;.  We
could easily implement this with boolean options like above, but there are
several problems with this strategy:</p>
<ol class="arabic simple">
<li>A user could specify more than one of the options at a time, for example,
&#8220;<tt class="docutils literal"><span class="pre">compiler</span> <span class="pre">-O3</span> <span class="pre">-O2</span></tt>&#8221;.  The CommandLine library would not be able to catch
this erroneous input for us.</li>
<li>We would have to test 4 different variables to see which ones are set.</li>
<li>This doesn&#8217;t map to the numeric levels that we want... so we cannot easily
see if some level &gt;= &#8220;<tt class="docutils literal"><span class="pre">-O1</span></tt>&#8221; is enabled.</li>
</ol>
<p>To cope with these problems, we can use an enum value, and have the CommandLine
library fill it in with the appropriate level directly, which is used like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">OptLevel</span> <span class="p">{</span>
  <span class="n">g</span><span class="p">,</span> <span class="n">O1</span><span class="p">,</span> <span class="n">O2</span><span class="p">,</span> <span class="n">O3</span>
<span class="p">};</span>

<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">OptLevel</span><span class="o">&gt;</span> <span class="n">OptimizationLevel</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Choose optimization level:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">g</span> <span class="p">,</span> <span class="s">&quot;No optimizations, enable debugging&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O1</span><span class="p">,</span> <span class="s">&quot;Enable trivial optimizations&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O2</span><span class="p">,</span> <span class="s">&quot;Enable default optimizations&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O3</span><span class="p">,</span> <span class="s">&quot;Enable expensive optimizations&quot;</span><span class="p">),</span>
   <span class="n">clEnumValEnd</span><span class="p">));</span>

<span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OptimizationLevel</span> <span class="o">&gt;=</span> <span class="n">O2</span><span class="p">)</span> <span class="n">doPartialRedundancyElimination</span><span class="p">(...);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This declaration defines a variable &#8220;<tt class="docutils literal"><span class="pre">OptimizationLevel</span></tt>&#8221; of the
&#8220;<tt class="docutils literal"><span class="pre">OptLevel</span></tt>&#8221; enum type.  This variable can be assigned any of the values that
are listed in the declaration (Note that the declaration list must be terminated
with the &#8220;<tt class="docutils literal"><span class="pre">clEnumValEnd</span></tt>&#8221; argument!).  The CommandLine library enforces that
the user can only specify one of the options, and it ensure that only valid enum
values can be specified.  The &#8220;<tt class="docutils literal"><span class="pre">clEnumVal</span></tt>&#8221; macros ensure that the command
line arguments matched the enum values.  With this option added, our help output
now is:</p>
<div class="highlight-python"><pre>USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  Choose optimization level:
    -g          - No optimizations, enable debugging
    -O1         - Enable trivial optimizations
    -O2         - Enable default optimizations
    -O3         - Enable expensive optimizations
  -f            - Enable binary output on terminals
  -help         - display available options (-help-hidden for more)
  -o &lt;filename&gt; - Specify output filename
  -quiet        - Don't print informational messages</pre>
</div>
<p>In this case, it is sort of awkward that flag names correspond directly to enum
names, because we probably don&#8217;t want a enum definition named &#8220;<tt class="docutils literal"><span class="pre">g</span></tt>&#8221; in our
program.  Because of this, we can alternatively write this example like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">OptLevel</span> <span class="p">{</span>
  <span class="n">Debug</span><span class="p">,</span> <span class="n">O1</span><span class="p">,</span> <span class="n">O2</span><span class="p">,</span> <span class="n">O3</span>
<span class="p">};</span>

<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">OptLevel</span><span class="o">&gt;</span> <span class="n">OptimizationLevel</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Choose optimization level:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
   <span class="n">clEnumValN</span><span class="p">(</span><span class="n">Debug</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="s">&quot;No optimizations, enable debugging&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O1</span>        <span class="p">,</span> <span class="s">&quot;Enable trivial optimizations&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O2</span>        <span class="p">,</span> <span class="s">&quot;Enable default optimizations&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O3</span>        <span class="p">,</span> <span class="s">&quot;Enable expensive optimizations&quot;</span><span class="p">),</span>
   <span class="n">clEnumValEnd</span><span class="p">));</span>

<span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OptimizationLevel</span> <span class="o">==</span> <span class="n">Debug</span><span class="p">)</span> <span class="n">outputDebugInfo</span><span class="p">(...);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>By using the &#8220;<tt class="docutils literal"><span class="pre">clEnumValN</span></tt>&#8221; macro instead of &#8220;<tt class="docutils literal"><span class="pre">clEnumVal</span></tt>&#8221;, we can directly
specify the name that the flag should get.  In general a direct mapping is nice,
but sometimes you can&#8217;t or don&#8217;t want to preserve the mapping, which is when you
would use it.</p>
</div>
<div class="section" id="named-alternatives">
<h3>Named Alternatives<a class="headerlink" href="#named-alternatives" title="Permalink to this headline">¶</a></h3>
<p>Another useful argument form is a named alternative style.  We shall use this
style in our compiler to specify different debug levels that can be used.
Instead of each debug level being its own switch, we want to support the
following options, of which only one can be specified at a time:
&#8220;<tt class="docutils literal"><span class="pre">--debug-level=none</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">--debug-level=quick</span></tt>&#8221;,
&#8220;<tt class="docutils literal"><span class="pre">--debug-level=detailed</span></tt>&#8221;.  To do this, we use the exact same format as our
optimization level flags, but we also specify an option name.  For this case,
the code looks like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">DebugLev</span> <span class="p">{</span>
  <span class="n">nodebuginfo</span><span class="p">,</span> <span class="n">quick</span><span class="p">,</span> <span class="n">detailed</span>
<span class="p">};</span>

<span class="c1">// Enable Debug Options to be specified on the command line</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">DebugLev</span><span class="o">&gt;</span> <span class="n">DebugLevel</span><span class="p">(</span><span class="s">&quot;debug_level&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Set the debugging level:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
    <span class="n">clEnumValN</span><span class="p">(</span><span class="n">nodebuginfo</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="s">&quot;disable debug information&quot;</span><span class="p">),</span>
     <span class="n">clEnumVal</span><span class="p">(</span><span class="n">quick</span><span class="p">,</span>               <span class="s">&quot;enable quick debug information&quot;</span><span class="p">),</span>
     <span class="n">clEnumVal</span><span class="p">(</span><span class="n">detailed</span><span class="p">,</span>            <span class="s">&quot;enable detailed debug information&quot;</span><span class="p">),</span>
    <span class="n">clEnumValEnd</span><span class="p">));</span>
</pre></div>
</div>
<p>This definition defines an enumerated command line variable of type &#8220;<tt class="docutils literal"><span class="pre">enum</span>
<span class="pre">DebugLev</span></tt>&#8221;, which works exactly the same way as before.  The difference here is
just the interface exposed to the user of your program and the help output by
the &#8220;<tt class="docutils literal"><span class="pre">-help</span></tt>&#8221; option:</p>
<div class="highlight-python"><pre>USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  Choose optimization level:
    -g          - No optimizations, enable debugging
    -O1         - Enable trivial optimizations
    -O2         - Enable default optimizations
    -O3         - Enable expensive optimizations
  -debug_level  - Set the debugging level:
    =none       - disable debug information
    =quick      - enable quick debug information
    =detailed   - enable detailed debug information
  -f            - Enable binary output on terminals
  -help         - display available options (-help-hidden for more)
  -o &lt;filename&gt; - Specify output filename
  -quiet        - Don't print informational messages</pre>
</div>
<p>Again, the only structural difference between the debug level declaration and
the optimization level declaration is that the debug level declaration includes
an option name (<tt class="docutils literal"><span class="pre">&quot;debug_level&quot;</span></tt>), which automatically changes how the library
processes the argument.  The CommandLine library supports both forms so that you
can choose the form most appropriate for your application.</p>
</div>
<div class="section" id="parsing-a-list-of-options">
<span id="lists"></span><h3>Parsing a list of options<a class="headerlink" href="#parsing-a-list-of-options" title="Permalink to this headline">¶</a></h3>
<p>Now that we have the standard run-of-the-mill argument types out of the way,
lets get a little wild and crazy.  Lets say that we want our optimizer to accept
a <strong>list</strong> of optimizations to perform, allowing duplicates.  For example, we
might want to run: &#8220;<tt class="docutils literal"><span class="pre">compiler</span> <span class="pre">-dce</span> <span class="pre">-constprop</span> <span class="pre">-inline</span> <span class="pre">-dce</span> <span class="pre">-strip</span></tt>&#8221;.  In this
case, the order of the arguments and the number of appearances is very
important.  This is what the &#8220;<tt class="docutils literal"><span class="pre">cl::list</span></tt>&#8221; template is for.  First, start by
defining an enum of the optimizations that you would like to perform:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">Opts</span> <span class="p">{</span>
  <span class="c1">// &#39;inline&#39; is a C++ keyword, so name it &#39;inlining&#39;</span>
  <span class="n">dce</span><span class="p">,</span> <span class="n">constprop</span><span class="p">,</span> <span class="n">inlining</span><span class="p">,</span> <span class="n">strip</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Then define your &#8220;<tt class="docutils literal"><span class="pre">cl::list</span></tt>&#8221; variable:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Opts</span><span class="o">&gt;</span> <span class="n">OptimizationList</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Available Optimizations:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">dce</span>               <span class="p">,</span> <span class="s">&quot;Dead Code Elimination&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">constprop</span>         <span class="p">,</span> <span class="s">&quot;Constant Propagation&quot;</span><span class="p">),</span>
   <span class="n">clEnumValN</span><span class="p">(</span><span class="n">inlining</span><span class="p">,</span> <span class="s">&quot;inline&quot;</span><span class="p">,</span> <span class="s">&quot;Procedure Integration&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">strip</span>             <span class="p">,</span> <span class="s">&quot;Strip Symbols&quot;</span><span class="p">),</span>
  <span class="n">clEnumValEnd</span><span class="p">));</span>
</pre></div>
</div>
<p>This defines a variable that is conceptually of the type
&#8220;<tt class="docutils literal"><span class="pre">std::vector&lt;enum</span> <span class="pre">Opts&gt;</span></tt>&#8221;.  Thus, you can access it with standard vector
methods:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">OptimizationList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">OptimizationList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
     <span class="p">...</span>
</pre></div>
</div>
<p>... to iterate through the list of options specified.</p>
<p>Note that the &#8220;<tt class="docutils literal"><span class="pre">cl::list</span></tt>&#8221; template is completely general and may be used with
any data types or other arguments that you can use with the &#8220;<tt class="docutils literal"><span class="pre">cl::opt</span></tt>&#8221;
template.  One especially useful way to use a list is to capture all of the
positional arguments together if there may be more than one specified.  In the
case of a linker, for example, the linker takes several &#8216;<tt class="docutils literal"><span class="pre">.o</span></tt>&#8216; files, and
needs to capture them into a list.  This is naturally specified as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">InputFilenames</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;Input files&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">OneOrMore</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This variable works just like a &#8220;<tt class="docutils literal"><span class="pre">vector&lt;string&gt;</span></tt>&#8221; object.  As such, accessing
the list is simple, just like above.  In this example, we used the
<a class="reference internal" href="#cl-oneormore">cl::OneOrMore</a> modifier to inform the CommandLine library that it is an error
if the user does not specify any <tt class="docutils literal"><span class="pre">.o</span></tt> files on our command line.  Again, this
just reduces the amount of checking we have to do.</p>
</div>
<div class="section" id="collecting-options-as-a-set-of-flags">
<h3>Collecting options as a set of flags<a class="headerlink" href="#collecting-options-as-a-set-of-flags" title="Permalink to this headline">¶</a></h3>
<p>Instead of collecting sets of options in a list, it is also possible to gather
information for enum values in a <strong>bit vector</strong>.  The representation used by the
<a class="reference internal" href="#cl-bits">cl::bits</a> class is an <tt class="docutils literal"><span class="pre">unsigned</span></tt> integer.  An enum value is represented by a
0/1 in the enum&#8217;s ordinal value bit position. 1 indicating that the enum was
specified, 0 otherwise.  As each specified value is parsed, the resulting enum&#8217;s
bit is set in the option&#8217;s bit vector:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">bits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="k">enum</span><span class="p">;</span>
</pre></div>
</div>
<p>Options that are specified multiple times are redundant.  Any instances after
the first are discarded.</p>
<p>Reworking the above list example, we could replace <a class="reference internal" href="#cl-list">cl::list</a> with <a class="reference internal" href="#cl-bits">cl::bits</a>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">bits</span><span class="o">&lt;</span><span class="n">Opts</span><span class="o">&gt;</span> <span class="n">OptimizationBits</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Available Optimizations:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">dce</span>               <span class="p">,</span> <span class="s">&quot;Dead Code Elimination&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">constprop</span>         <span class="p">,</span> <span class="s">&quot;Constant Propagation&quot;</span><span class="p">),</span>
   <span class="n">clEnumValN</span><span class="p">(</span><span class="n">inlining</span><span class="p">,</span> <span class="s">&quot;inline&quot;</span><span class="p">,</span> <span class="s">&quot;Procedure Integration&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">strip</span>             <span class="p">,</span> <span class="s">&quot;Strip Symbols&quot;</span><span class="p">),</span>
  <span class="n">clEnumValEnd</span><span class="p">));</span>
</pre></div>
</div>
<p>To test to see if <tt class="docutils literal"><span class="pre">constprop</span></tt> was specified, we can use the <tt class="docutils literal"><span class="pre">cl:bits::isSet</span></tt>
function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">OptimizationBits</span><span class="p">.</span><span class="n">isSet</span><span class="p">(</span><span class="n">constprop</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It&#8217;s also possible to get the raw bit vector using the <tt class="docutils literal"><span class="pre">cl::bits::getBits</span></tt>
function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">OptimizationBits</span><span class="p">.</span><span class="n">getBits</span><span class="p">();</span>
</pre></div>
</div>
<p>Finally, if external storage is used, then the location specified must be of
<strong>type</strong> <tt class="docutils literal"><span class="pre">unsigned</span></tt>. In all other ways a <a class="reference internal" href="#cl-bits">cl::bits</a> option is equivalent to a
<a class="reference internal" href="#cl-list">cl::list</a> option.</p>
</div>
<div class="section" id="adding-freeform-text-to-help-output">
<span id="additional-extra-text"></span><h3>Adding freeform text to help output<a class="headerlink" href="#adding-freeform-text-to-help-output" title="Permalink to this headline">¶</a></h3>
<p>As our program grows and becomes more mature, we may decide to put summary
information about what it does into the help output.  The help output is styled
to look similar to a Unix <tt class="docutils literal"><span class="pre">man</span></tt> page, providing concise information about a
program.  Unix <tt class="docutils literal"><span class="pre">man</span></tt> pages, however often have a description about what the
program does.  To add this to your CommandLine program, simply pass a third
argument to the <a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a> call in main.  This additional
argument is then printed as the overview information for your program, allowing
you to include any additional information that you want.  For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">ParseCommandLineOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot; CommandLine compiler example</span><span class="se">\n\n</span><span class="s">&quot;</span>
                              <span class="s">&quot;  This program blah blah blah...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>would yield the help output:</p>
<div class="highlight-python"><pre>**OVERVIEW: CommandLine compiler example

  This program blah blah blah...**

USAGE: compiler [options] &lt;input file&gt;

OPTIONS:
  ...
  -help             - display available options (-help-hidden for more)
  -o &lt;filename&gt;     - Specify output filename</pre>
</div>
</div>
</div>
<div class="section" id="reference-guide">
<span id="id1"></span><h2>Reference Guide<a class="headerlink" href="#reference-guide" title="Permalink to this headline">¶</a></h2>
<p>Now that you know the basics of how to use the CommandLine library, this section
will give you the detailed information you need to tune how command line options
work, as well as information on more &#8220;advanced&#8221; command line option processing
capabilities.</p>
<div class="section" id="positional-options">
<span id="positional-arguments-section"></span><span id="positional-arguments"></span><span id="positional-argument"></span><span id="positional"></span><span id="id2"></span><h3>Positional Arguments<a class="headerlink" href="#positional-options" title="Permalink to this headline">¶</a></h3>
<p>Positional arguments are those arguments that are not named, and are not
specified with a hyphen.  Positional arguments should be used when an option is
specified by its position alone.  For example, the standard Unix <tt class="docutils literal"><span class="pre">grep</span></tt> tool
takes a regular expression argument, and an optional filename to search through
(which defaults to standard input if a filename is not specified).  Using the
CommandLine library, this would be specified as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Regex</span>   <span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;regular expression&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">Required</span><span class="p">);</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Filename</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input file&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Given these two option declarations, the <tt class="docutils literal"><span class="pre">-help</span></tt> output for our grep
replacement would look like this:</p>
<div class="highlight-python"><pre>USAGE: spiffygrep [options] &lt;regular expression&gt; &lt;input file&gt;

OPTIONS:
  -help - display available options (-help-hidden for more)</pre>
</div>
<p>... and the resultant program could be used just like the standard <tt class="docutils literal"><span class="pre">grep</span></tt>
tool.</p>
<p>Positional arguments are sorted by their order of construction.  This means that
command line options will be ordered according to how they are listed in a .cpp
file, but will not have an ordering defined if the positional arguments are
defined in multiple .cpp files.  The fix for this problem is simply to define
all of your positional arguments in one .cpp file.</p>
<div class="section" id="specifying-positional-options-with-hyphens">
<h4>Specifying positional options with hyphens<a class="headerlink" href="#specifying-positional-options-with-hyphens" title="Permalink to this headline">¶</a></h4>
<p>Sometimes you may want to specify a value to your positional argument that
starts with a hyphen (for example, searching for &#8216;<tt class="docutils literal"><span class="pre">-foo</span></tt>&#8216; in a file).  At
first, you will have trouble doing this, because it will try to find an argument
named &#8216;<tt class="docutils literal"><span class="pre">-foo</span></tt>&#8216;, and will fail (and single quotes will not save you).  Note
that the system <tt class="docutils literal"><span class="pre">grep</span></tt> has the same problem:</p>
<div class="highlight-python"><pre>$ spiffygrep '-foo' test.txt
Unknown command line argument '-foo'.  Try: spiffygrep -help'

$ grep '-foo' test.txt
grep: illegal option -- f
grep: illegal option -- o
grep: illegal option -- o
Usage: grep -hblcnsviw pattern file . . .</pre>
</div>
<p>The solution for this problem is the same for both your tool and the system
version: use the &#8216;<tt class="docutils literal"><span class="pre">--</span></tt>&#8216; marker.  When the user specifies &#8216;<tt class="docutils literal"><span class="pre">--</span></tt>&#8216; on the
command line, it is telling the program that all options after the &#8216;<tt class="docutils literal"><span class="pre">--</span></tt>&#8216;
should be treated as positional arguments, not options.  Thus, we can use it
like this:</p>
<div class="highlight-python"><pre>$ spiffygrep -- -foo test.txt
  ...output...</pre>
</div>
</div>
<div class="section" id="determining-absolute-position-with-getposition">
<h4>Determining absolute position with getPosition()<a class="headerlink" href="#determining-absolute-position-with-getposition" title="Permalink to this headline">¶</a></h4>
<p>Sometimes an option can affect or modify the meaning of another option. For
example, consider <tt class="docutils literal"><span class="pre">gcc</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">-x</span> <span class="pre">LANG</span></tt> option. This tells <tt class="docutils literal"><span class="pre">gcc</span></tt> to ignore the
suffix of subsequent positional arguments and force the file to be interpreted
as if it contained source code in language <tt class="docutils literal"><span class="pre">LANG</span></tt>. In order to handle this
properly, you need to know the absolute position of each argument, especially
those in lists, so their interaction(s) can be applied correctly. This is also
useful for options like <tt class="docutils literal"><span class="pre">-llibname</span></tt> which is actually a positional argument
that starts with a dash.</p>
<p>So, generally, the problem is that you have two <tt class="docutils literal"><span class="pre">cl::list</span></tt> variables that
interact in some way. To ensure the correct interaction, you can use the
<tt class="docutils literal"><span class="pre">cl::list::getPosition(optnum)</span></tt> method. This method returns the absolute
position (as found on the command line) of the <tt class="docutils literal"><span class="pre">optnum</span></tt> item in the
<tt class="docutils literal"><span class="pre">cl::list</span></tt>.</p>
<p>The idiom for usage is like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Files</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">OneOrMore</span><span class="p">);</span>
<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Libraries</span><span class="p">(</span><span class="s">&quot;l&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">ZeroOrMore</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">fileIt</span> <span class="o">=</span> <span class="n">Files</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">libIt</span>  <span class="o">=</span> <span class="n">Libraries</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">libPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">filePos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">libIt</span> <span class="o">!=</span> <span class="n">Libraries</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
      <span class="n">libPos</span> <span class="o">=</span> <span class="n">Libraries</span><span class="p">.</span><span class="n">getPosition</span><span class="p">(</span> <span class="n">libIt</span> <span class="o">-</span> <span class="n">Libraries</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">);</span>
    <span class="k">else</span>
      <span class="n">libPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">fileIt</span> <span class="o">!=</span> <span class="n">Files</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
      <span class="n">filePos</span> <span class="o">=</span> <span class="n">Files</span><span class="p">.</span><span class="n">getPosition</span><span class="p">(</span> <span class="n">fileIt</span> <span class="o">-</span> <span class="n">Files</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">);</span>
    <span class="k">else</span>
      <span class="n">filePos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">filePos</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">libPos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">filePos</span> <span class="o">&lt;</span> <span class="n">libPos</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Source File Is next</span>
      <span class="o">++</span><span class="n">fileIt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">libPos</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">filePos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">libPos</span> <span class="o">&lt;</span> <span class="n">filePos</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Library is next</span>
      <span class="o">++</span><span class="n">libIt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
      <span class="k">break</span><span class="p">;</span> <span class="c1">// we&#39;re done with the list</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that, for compatibility reasons, the <tt class="docutils literal"><span class="pre">cl::opt</span></tt> also supports an
<tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">getPosition()</span></tt> option that will provide the absolute position of
that option. You can apply the same approach as above with a <tt class="docutils literal"><span class="pre">cl::opt</span></tt> and a
<tt class="docutils literal"><span class="pre">cl::list</span></tt> option as you can with two lists.</p>
</div>
<div class="section" id="the-cl-consumeafter-modifier">
<span id="this-section-for-more-information"></span><span id="cl-consumeafter"></span><span id="interpreter-style-options"></span><h4>The <tt class="docutils literal"><span class="pre">cl::ConsumeAfter</span></tt> modifier<a class="headerlink" href="#the-cl-consumeafter-modifier" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::ConsumeAfter</span></tt> <a class="reference internal" href="#formatting-option">formatting option</a> is used to construct programs that
use &#8220;interpreter style&#8221; option processing.  With this style of option
processing, all arguments specified after the last positional argument are
treated as special interpreter arguments that are not interpreted by the command
line argument.</p>
<p>As a concrete example, lets say we are developing a replacement for the standard
Unix Bourne shell (<tt class="docutils literal"><span class="pre">/bin/sh</span></tt>).  To run <tt class="docutils literal"><span class="pre">/bin/sh</span></tt>, first you specify options
to the shell itself (like <tt class="docutils literal"><span class="pre">-x</span></tt> which turns on trace output), then you specify
the name of the script to run, then you specify arguments to the script.  These
arguments to the script are parsed by the Bourne shell command line option
processor, but are not interpreted as options to the shell itself.  Using the
CommandLine library, we would specify this as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Script</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input script&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>  <span class="n">Argv</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">ConsumeAfter</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;program arguments&gt;...&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>    <span class="n">Trace</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Enable trace output&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>which automatically provides the help output:</p>
<div class="highlight-python"><pre>USAGE: spiffysh [options] &lt;input script&gt; &lt;program arguments&gt;...

OPTIONS:
  -help - display available options (-help-hidden for more)
  -x    - Enable trace output</pre>
</div>
<p>At runtime, if we run our new shell replacement as <tt class="docutils literal"><span class="pre">`spiffysh</span> <span class="pre">-x</span> <span class="pre">test.sh</span> <span class="pre">-a</span> <span class="pre">-x</span>
<span class="pre">-y</span> <span class="pre">bar</span></tt>&#8216;, the <tt class="docutils literal"><span class="pre">Trace</span></tt> variable will be set to true, the <tt class="docutils literal"><span class="pre">Script</span></tt> variable
will be set to &#8220;<tt class="docutils literal"><span class="pre">test.sh</span></tt>&#8221;, and the <tt class="docutils literal"><span class="pre">Argv</span></tt> list will contain <tt class="docutils literal"><span class="pre">[&quot;-a&quot;,</span> <span class="pre">&quot;-x&quot;,</span>
<span class="pre">&quot;-y&quot;,</span> <span class="pre">&quot;bar&quot;]</span></tt>, because they were specified after the last positional argument
(which is the script name).</p>
<p>There are several limitations to when <tt class="docutils literal"><span class="pre">cl::ConsumeAfter</span></tt> options can be
specified.  For example, only one <tt class="docutils literal"><span class="pre">cl::ConsumeAfter</span></tt> can be specified per
program, there must be at least one <a class="reference internal" href="#positional-argument">positional argument</a> specified, there must
not be any <a class="reference internal" href="#cl-list">cl::list</a> positional arguments, and the <tt class="docutils literal"><span class="pre">cl::ConsumeAfter</span></tt> option
should be a <a class="reference internal" href="#cl-list">cl::list</a> option.</p>
</div>
</div>
<div class="section" id="internal-vs-external-storage">
<span id="can-be-changed"></span><span id="id3"></span><h3>Internal vs External Storage<a class="headerlink" href="#internal-vs-external-storage" title="Permalink to this headline">¶</a></h3>
<p>By default, all command line options automatically hold the value that they
parse from the command line.  This is very convenient in the common case,
especially when combined with the ability to define command line options in the
files that use them.  This is called the internal storage model.</p>
<p>Sometimes, however, it is nice to separate the command line option processing
code from the storage of the value parsed.  For example, lets say that we have a
&#8216;<tt class="docutils literal"><span class="pre">-debug</span></tt>&#8216; option that we would like to use to enable debug information across
the entire body of our program.  In this case, the boolean value controlling the
debug code should be globally accessible (in a header file, for example) yet the
command line option processing code should not be exposed to all of these
clients (requiring lots of .cpp files to <tt class="docutils literal"><span class="pre">#include</span> <span class="pre">CommandLine.h</span></tt>).</p>
<p>To do this, set up your .h file with your option, like this for example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// DebugFlag.h - Get access to the &#39;-debug&#39; command line option</span>
<span class="c1">//</span>

<span class="c1">// DebugFlag - This boolean is set to true if the &#39;-debug&#39; command line option</span>
<span class="c1">// is specified.  This should probably not be referenced directly, instead, use</span>
<span class="c1">// the DEBUG macro below.</span>
<span class="c1">//</span>
<span class="k">extern</span> <span class="kt">bool</span> <span class="n">DebugFlag</span><span class="p">;</span>

<span class="c1">// DEBUG macro - This macro should be used by code to emit debug information.</span>
<span class="c1">// In the &#39;-debug&#39; option is specified on the command line, and if this is a</span>
<span class="c1">// debug build, then the code specified as the option to the macro will be</span>
<span class="c1">// executed.  Otherwise it will not be.</span>
<span class="cp">#ifdef NDEBUG</span>
<span class="cp">#define DEBUG(X)</span>
<span class="cp">#else</span>
<span class="cp">#define DEBUG(X) do { if (DebugFlag) { X; } } while (0)</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>This allows clients to blissfully use the <tt class="docutils literal"><span class="pre">DEBUG()</span></tt> macro, or the
<tt class="docutils literal"><span class="pre">DebugFlag</span></tt> explicitly if they want to.  Now we just need to be able to set
the <tt class="docutils literal"><span class="pre">DebugFlag</span></tt> boolean when the option is set.  To do this, we pass an
additional argument to our command line argument processor, and we specify where
to fill in with the <a class="reference internal" href="#cl-location">cl::location</a> attribute:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">DebugFlag</span><span class="p">;</span>                  <span class="c1">// the actual value</span>
<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="kc">true</span><span class="o">&gt;</span>       <span class="c1">// The parser</span>
<span class="n">Debug</span><span class="p">(</span><span class="s">&quot;debug&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Enable debug output&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">location</span><span class="p">(</span><span class="n">DebugFlag</span><span class="p">));</span>
</pre></div>
</div>
<p>In the above example, we specify &#8220;<tt class="docutils literal"><span class="pre">true</span></tt>&#8221; as the second argument to the
<a class="reference internal" href="#cl-opt">cl::opt</a> template, indicating that the template should not maintain a copy of
the value itself.  In addition to this, we specify the <a class="reference internal" href="#cl-location">cl::location</a>
attribute, so that <tt class="docutils literal"><span class="pre">DebugFlag</span></tt> is automatically set.</p>
</div>
<div class="section" id="option-attributes">
<h3>Option Attributes<a class="headerlink" href="#option-attributes" title="Permalink to this headline">¶</a></h3>
<p>This section describes the basic attributes that you can specify on options.</p>
<ul>
<li><p class="first">The option name attribute (which is required for all options, except
<a class="reference internal" href="#positional-options">positional options</a>) specifies what the option name is.  This option is
specified in simple double quotes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;**</span><span class="kt">bool</span><span class="o">**&gt;</span> <span class="n">Quiet</span><span class="p">(</span><span class="s">&quot;quiet&quot;</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
<ul class="simple" id="cl-desc">
<li>The <strong>cl::desc</strong> attribute specifies a description for the option to be
shown in the <tt class="docutils literal"><span class="pre">-help</span></tt> output for the program.</li>
</ul>
<ul class="simple" id="cl-value-desc">
<li>The <strong>cl::value_desc</strong> attribute specifies a string that can be used to
fine tune the <tt class="docutils literal"><span class="pre">-help</span></tt> output for a command line option.  Look <a class="reference internal" href="#here">here</a> for an
example.</li>
</ul>
<ul id="cl-init">
<li><p class="first">The <strong>cl::init</strong> attribute specifies an initial value for a <a class="reference internal" href="#scalar">scalar</a>
option.  If this attribute is not specified then the command line option value
defaults to the value created by the default constructor for the
type.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If you specify both <strong>cl::init</strong> and <strong>cl::location</strong> for an option, you
must specify <strong>cl::location</strong> first, so that when the command-line parser
sees <strong>cl::init</strong>, it knows where to put the initial value. (You will get an
error at runtime if you don&#8217;t put them in the right order.)</p>
</div>
</li>
</ul>
<ul class="simple" id="cl-location">
<li>The <strong>cl::location</strong> attribute where to store the value for a parsed command
line option if using external storage.  See the section on <a class="reference internal" href="#internal-vs-external-storage">Internal vs
External Storage</a> for more information.</li>
</ul>
<ul class="simple" id="cl-aliasopt">
<li>The <strong>cl::aliasopt</strong> attribute specifies which option a <a class="reference internal" href="#cl-alias">cl::alias</a> option is
an alias for.</li>
</ul>
<ul id="cl-values">
<li><p class="first">The <strong>cl::values</strong> attribute specifies the string-to-value mapping to be used
by the generic parser.  It takes a <strong>clEnumValEnd terminated</strong> list of
(option, value, description) triplets that specify the option name, the value
mapped to, and the description shown in the <tt class="docutils literal"><span class="pre">-help</span></tt> for the tool.  Because
the generic parser is used most frequently with enum values, two macros are
often useful:</p>
<ol class="arabic simple">
<li>The <strong>clEnumVal</strong> macro is used as a nice simple way to specify a triplet
for an enum.  This macro automatically makes the option name be the same as
the enum name.  The first option to the macro is the enum, the second is
the description for the command line option.</li>
<li>The <strong>clEnumValN</strong> macro is used to specify macro options where the option
name doesn&#8217;t equal the enum name.  For this macro, the first argument is
the enum value, the second is the flag name, and the second is the
description.</li>
</ol>
<p>You will get a compile time error if you try to use cl::values with a parser
that does not support it.</p>
</li>
</ul>
<ul class="simple" id="cl-multi-val">
<li>The <strong>cl::multi_val</strong> attribute specifies that this option takes has multiple
values (example: <tt class="docutils literal"><span class="pre">-sectalign</span> <span class="pre">segname</span> <span class="pre">sectname</span> <span class="pre">sectvalue</span></tt>). This attribute
takes one unsigned argument - the number of values for the option. This
attribute is valid only on <tt class="docutils literal"><span class="pre">cl::list</span></tt> options (and will fail with compile
error if you try to use it with other option types). It is allowed to use all
of the usual modifiers on multi-valued options (besides
<tt class="docutils literal"><span class="pre">cl::ValueDisallowed</span></tt>, obviously).</li>
</ul>
</div>
<div class="section" id="option-modifiers">
<h3>Option Modifiers<a class="headerlink" href="#option-modifiers" title="Permalink to this headline">¶</a></h3>
<p>Option modifiers are the flags and expressions that you pass into the
constructors for <a class="reference internal" href="#cl-opt">cl::opt</a> and <a class="reference internal" href="#cl-list">cl::list</a>.  These modifiers give you the
ability to tweak how options are parsed and how <tt class="docutils literal"><span class="pre">-help</span></tt> output is generated to
fit your application well.</p>
<p>These options fall into five main categories:</p>
<ol class="arabic simple">
<li>Hiding an option from <tt class="docutils literal"><span class="pre">-help</span></tt> output</li>
<li>Controlling the number of occurrences required and allowed</li>
<li>Controlling whether or not a value must be specified</li>
<li>Controlling other formatting options</li>
<li>Miscellaneous option modifiers</li>
</ol>
<p>It is not possible to specify two options from the same category (you&#8217;ll get a
runtime error) to a single option, except for options in the miscellaneous
category.  The CommandLine library specifies defaults for all of these settings
that are the most useful in practice and the most common, which mean that you
usually shouldn&#8217;t have to worry about these.</p>
<div class="section" id="hiding-an-option-from-help-output">
<h4>Hiding an option from <tt class="docutils literal"><span class="pre">-help</span></tt> output<a class="headerlink" href="#hiding-an-option-from-help-output" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::NotHidden</span></tt>, <tt class="docutils literal"><span class="pre">cl::Hidden</span></tt>, and <tt class="docutils literal"><span class="pre">cl::ReallyHidden</span></tt> modifiers are
used to control whether or not an option appears in the <tt class="docutils literal"><span class="pre">-help</span></tt> and
<tt class="docutils literal"><span class="pre">-help-hidden</span></tt> output for the compiled program:</p>
<ul class="simple" id="cl-nothidden">
<li>The <strong>cl::NotHidden</strong> modifier (which is the default for <a class="reference internal" href="#cl-opt">cl::opt</a> and
<a class="reference internal" href="#cl-list">cl::list</a> options) indicates the option is to appear in both help
listings.</li>
</ul>
<ul class="simple" id="cl-hidden">
<li>The <strong>cl::Hidden</strong> modifier (which is the default for <a class="reference internal" href="#cl-alias">cl::alias</a> options)
indicates that the option should not appear in the <tt class="docutils literal"><span class="pre">-help</span></tt> output, but
should appear in the <tt class="docutils literal"><span class="pre">-help-hidden</span></tt> output.</li>
</ul>
<ul class="simple" id="cl-reallyhidden">
<li>The <strong>cl::ReallyHidden</strong> modifier indicates that the option should not appear
in any help output.</li>
</ul>
</div>
<div class="section" id="controlling-the-number-of-occurrences-required-and-allowed">
<h4>Controlling the number of occurrences required and allowed<a class="headerlink" href="#controlling-the-number-of-occurrences-required-and-allowed" title="Permalink to this headline">¶</a></h4>
<p>This group of options is used to control how many time an option is allowed (or
required) to be specified on the command line of your program.  Specifying a
value for this setting allows the CommandLine library to do error checking for
you.</p>
<p>The allowed values for this option group are:</p>
<ul class="simple" id="cl-optional">
<li>The <strong>cl::Optional</strong> modifier (which is the default for the <a class="reference internal" href="#cl-opt">cl::opt</a> and
<a class="reference internal" href="#cl-alias">cl::alias</a> classes) indicates that your program will allow either zero or
one occurrence of the option to be specified.</li>
</ul>
<ul class="simple" id="cl-zeroormore">
<li>The <strong>cl::ZeroOrMore</strong> modifier (which is the default for the <a class="reference internal" href="#cl-list">cl::list</a>
class) indicates that your program will allow the option to be specified zero
or more times.</li>
</ul>
<ul class="simple" id="cl-required">
<li>The <strong>cl::Required</strong> modifier indicates that the specified option must be
specified exactly one time.</li>
</ul>
<ul class="simple" id="cl-oneormore">
<li>The <strong>cl::OneOrMore</strong> modifier indicates that the option must be specified at
least one time.</li>
<li>The <strong>cl::ConsumeAfter</strong> modifier is described in the <a class="reference internal" href="#positional-arguments-section">Positional arguments
section</a>.</li>
</ul>
<p>If an option is not specified, then the value of the option is equal to the
value specified by the <a class="reference internal" href="#cl-init">cl::init</a> attribute.  If the <tt class="docutils literal"><span class="pre">cl::init</span></tt> attribute is
not specified, the option value is initialized with the default constructor for
the data type.</p>
<p>If an option is specified multiple times for an option of the <a class="reference internal" href="#cl-opt">cl::opt</a> class,
only the last value will be retained.</p>
</div>
<div class="section" id="controlling-whether-or-not-a-value-must-be-specified">
<h4>Controlling whether or not a value must be specified<a class="headerlink" href="#controlling-whether-or-not-a-value-must-be-specified" title="Permalink to this headline">¶</a></h4>
<p>This group of options is used to control whether or not the option allows a
value to be present.  In the case of the CommandLine library, a value is either
specified with an equal sign (e.g. &#8216;<tt class="docutils literal"><span class="pre">-index-depth=17</span></tt>&#8216;) or as a trailing
string (e.g. &#8216;<tt class="docutils literal"><span class="pre">-o</span> <span class="pre">a.out</span></tt>&#8216;).</p>
<p>The allowed values for this option group are:</p>
<ul class="simple" id="cl-valueoptional">
<li>The <strong>cl::ValueOptional</strong> modifier (which is the default for <tt class="docutils literal"><span class="pre">bool</span></tt> typed
options) specifies that it is acceptable to have a value, or not.  A boolean
argument can be enabled just by appearing on the command line, or it can have
an explicit &#8216;<tt class="docutils literal"><span class="pre">-foo=true</span></tt>&#8216;.  If an option is specified with this mode, it is
illegal for the value to be provided without the equal sign.  Therefore
&#8216;<tt class="docutils literal"><span class="pre">-foo</span> <span class="pre">true</span></tt>&#8216; is illegal.  To get this behavior, you must use
the <a class="reference internal" href="#cl-valuerequired">cl::ValueRequired</a> modifier.</li>
</ul>
<ul class="simple" id="cl-valuerequired">
<li>The <strong>cl::ValueRequired</strong> modifier (which is the default for all other types
except for <a class="reference internal" href="#unnamed-alternatives-using-the-generic-parser">unnamed alternatives using the generic parser</a>) specifies that a
value must be provided.  This mode informs the command line library that if an
option is not provides with an equal sign, that the next argument provided
must be the value.  This allows things like &#8216;<tt class="docutils literal"><span class="pre">-o</span> <span class="pre">a.out</span></tt>&#8216; to work.</li>
</ul>
<ul class="simple" id="cl-valuedisallowed">
<li>The <strong>cl::ValueDisallowed</strong> modifier (which is the default for <a class="reference internal" href="#unnamed-alternatives-using-the-generic-parser">unnamed
alternatives using the generic parser</a>) indicates that it is a runtime error
for the user to specify a value.  This can be provided to disallow users from
providing options to boolean options (like &#8216;<tt class="docutils literal"><span class="pre">-foo=true</span></tt>&#8216;).</li>
</ul>
<p>In general, the default values for this option group work just like you would
want them to.  As mentioned above, you can specify the <a class="reference internal" href="#cl-valuedisallowed">cl::ValueDisallowed</a>
modifier to a boolean argument to restrict your command line parser.  These
options are mostly useful when <a class="reference internal" href="#extending-the-library">extending the library</a>.</p>
</div>
<div class="section" id="controlling-other-formatting-options">
<span id="formatting-option"></span><h4>Controlling other formatting options<a class="headerlink" href="#controlling-other-formatting-options" title="Permalink to this headline">¶</a></h4>
<p>The formatting option group is used to specify that the command line option has
special abilities and is otherwise different from other command line arguments.
As usual, you can only specify one of these arguments at most.</p>
<ul class="simple" id="cl-normalformatting">
<li>The <strong>cl::NormalFormatting</strong> modifier (which is the default all options)
specifies that this option is &#8220;normal&#8221;.</li>
</ul>
<ul class="simple" id="cl-positional">
<li>The <strong>cl::Positional</strong> modifier specifies that this is a positional argument
that does not have a command line option associated with it.  See the
<a class="reference internal" href="#positional-arguments">Positional Arguments</a> section for more information.</li>
<li>The <strong>cl::ConsumeAfter</strong> modifier specifies that this option is used to
capture &#8220;interpreter style&#8221; arguments.  See <a class="reference internal" href="#this-section-for-more-information">this section for more
information</a>.</li>
</ul>
<ul class="simple" id="cl-prefix">
<span id="prefix"></span><li>The <strong>cl::Prefix</strong> modifier specifies that this option prefixes its value.
With &#8216;Prefix&#8217; options, the equal sign does not separate the value from the
option name specified. Instead, the value is everything after the prefix,
including any equal sign if present. This is useful for processing odd
arguments like <tt class="docutils literal"><span class="pre">-lmalloc</span></tt> and <tt class="docutils literal"><span class="pre">-L/usr/lib</span></tt> in a linker tool or
<tt class="docutils literal"><span class="pre">-DNAME=value</span></tt> in a compiler tool.  Here, the &#8216;<tt class="docutils literal"><span class="pre">l</span></tt>&#8216;, &#8216;<tt class="docutils literal"><span class="pre">D</span></tt>&#8216; and &#8216;<tt class="docutils literal"><span class="pre">L</span></tt>&#8216;
options are normal string (or list) options, that have the <strong>cl::Prefix</strong>
modifier added to allow the CommandLine library to recognize them.  Note that
<strong>cl::Prefix</strong> options must not have the <strong>cl::ValueDisallowed</strong> modifier
specified.</li>
</ul>
<ul class="simple" id="cl-grouping">
<span id="grouping"></span><li>The <strong>cl::Grouping</strong> modifier is used to implement Unix-style tools (like
<tt class="docutils literal"><span class="pre">ls</span></tt>) that have lots of single letter arguments, but only require a single
dash.  For example, the &#8216;<tt class="docutils literal"><span class="pre">ls</span> <span class="pre">-labF</span></tt>&#8216; command actually enables four different
options, all of which are single letters.  Note that <strong>cl::Grouping</strong> options
cannot have values.</li>
</ul>
<p>The CommandLine library does not restrict how you use the <strong>cl::Prefix</strong> or
<strong>cl::Grouping</strong> modifiers, but it is possible to specify ambiguous argument
settings.  Thus, it is possible to have multiple letter options that are prefix
or grouping options, and they will still work as designed.</p>
<p>To do this, the CommandLine library uses a greedy algorithm to parse the input
option into (potentially multiple) prefix and grouping options.  The strategy
basically looks like this:</p>
<div class="highlight-python"><pre>parse(string OrigInput) {

1. string input = OrigInput;
2. if (isOption(input)) return getOption(input).parse();  // Normal option
3. while (!isOption(input) &amp;&amp; !input.empty()) input.pop_back();  // Remove the last letter
4. if (input.empty()) return error();  // No matching option
5. if (getOption(input).isPrefix())
     return getOption(input).parse(input);
6. while (!input.empty()) {  // Must be grouping options
     getOption(input).parse();
     OrigInput.erase(OrigInput.begin(), OrigInput.begin()+input.length());
     input = OrigInput;
     while (!isOption(input) &amp;&amp; !input.empty()) input.pop_back();
   }
7. if (!OrigInput.empty()) error();

}</pre>
</div>
</div>
<div class="section" id="miscellaneous-option-modifiers">
<h4>Miscellaneous option modifiers<a class="headerlink" href="#miscellaneous-option-modifiers" title="Permalink to this headline">¶</a></h4>
<p>The miscellaneous option modifiers are the only flags where you can specify more
than one flag from the set: they are not mutually exclusive.  These flags
specify boolean properties that modify the option.</p>
<ul class="simple" id="cl-commaseparated">
<li>The <strong>cl::CommaSeparated</strong> modifier indicates that any commas specified for an
option&#8217;s value should be used to split the value up into multiple values for
the option.  For example, these two options are equivalent when
<tt class="docutils literal"><span class="pre">cl::CommaSeparated</span></tt> is specified: &#8220;<tt class="docutils literal"><span class="pre">-foo=a</span> <span class="pre">-foo=b</span> <span class="pre">-foo=c</span></tt>&#8221; and
&#8220;<tt class="docutils literal"><span class="pre">-foo=a,b,c</span></tt>&#8221;.  This option only makes sense to be used in a case where the
option is allowed to accept one or more values (i.e. it is a <a class="reference internal" href="#cl-list">cl::list</a>
option).</li>
</ul>
<ul class="simple" id="cl-positionaleatsargs">
<li>The <strong>cl::PositionalEatsArgs</strong> modifier (which only applies to positional
arguments, and only makes sense for lists) indicates that positional argument
should consume any strings after it (including strings that start with a &#8220;-&#8221;)
up until another recognized positional argument.  For example, if you have two
&#8220;eating&#8221; positional arguments, &#8220;<tt class="docutils literal"><span class="pre">pos1</span></tt>&#8221; and &#8220;<tt class="docutils literal"><span class="pre">pos2</span></tt>&#8221;, the string &#8220;<tt class="docutils literal"><span class="pre">-pos1</span>
<span class="pre">-foo</span> <span class="pre">-bar</span> <span class="pre">baz</span> <span class="pre">-pos2</span> <span class="pre">-bork</span></tt>&#8221; would cause the &#8220;<tt class="docutils literal"><span class="pre">-foo</span> <span class="pre">-bar</span> <span class="pre">-baz</span></tt>&#8221; strings to
be applied to the &#8220;<tt class="docutils literal"><span class="pre">-pos1</span></tt>&#8221; option and the &#8220;<tt class="docutils literal"><span class="pre">-bork</span></tt>&#8221; string to be applied
to the &#8220;<tt class="docutils literal"><span class="pre">-pos2</span></tt>&#8221; option.</li>
</ul>
<ul class="simple" id="cl-sink">
<li>The <strong>cl::Sink</strong> modifier is used to handle unknown options. If there is at
least one option with <tt class="docutils literal"><span class="pre">cl::Sink</span></tt> modifier specified, the parser passes
unrecognized option strings to it as values instead of signaling an error. As
with <tt class="docutils literal"><span class="pre">cl::CommaSeparated</span></tt>, this modifier only makes sense with a <a class="reference internal" href="#cl-list">cl::list</a>
option.</li>
</ul>
<p>So far, these are the only three miscellaneous option modifiers.</p>
</div>
<div class="section" id="response-files">
<span id="id4"></span><h4>Response files<a class="headerlink" href="#response-files" title="Permalink to this headline">¶</a></h4>
<p>Some systems, such as certain variants of Microsoft Windows and some older
Unices have a relatively low limit on command-line length. It is therefore
customary to use the so-called &#8216;response files&#8217; to circumvent this
restriction. These files are mentioned on the command-line (using the &#8220;&#64;file&#8221;)
syntax. The program reads these files and inserts the contents into argv,
thereby working around the command-line length limits. Response files are
enabled by an optional fourth argument to <a class="reference internal" href="#cl-parseenvironmentoptions">cl::ParseEnvironmentOptions</a> and
<a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a>.</p>
</div>
</div>
<div class="section" id="top-level-classes-and-functions">
<h3>Top-Level Classes and Functions<a class="headerlink" href="#top-level-classes-and-functions" title="Permalink to this headline">¶</a></h3>
<p>Despite all of the built-in flexibility, the CommandLine option library really
only consists of one function <a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a>) and three main
classes: <a class="reference internal" href="#cl-opt">cl::opt</a>, <a class="reference internal" href="#cl-list">cl::list</a>, and <a class="reference internal" href="#cl-alias">cl::alias</a>.  This section describes
these three classes in detail.</p>
<div class="section" id="the-cl-parsecommandlineoptions-function">
<span id="cl-parsecommandlineoptions"></span><h4>The <tt class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></tt> function<a class="headerlink" href="#the-cl-parsecommandlineoptions-function" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></tt> function is designed to be called directly
from <tt class="docutils literal"><span class="pre">main</span></tt>, and is used to fill in the values of all of the command line
option variables once <tt class="docutils literal"><span class="pre">argc</span></tt> and <tt class="docutils literal"><span class="pre">argv</span></tt> are available.</p>
<p>The <tt class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></tt> function requires two parameters (<tt class="docutils literal"><span class="pre">argc</span></tt>
and <tt class="docutils literal"><span class="pre">argv</span></tt>), but may also take an optional third parameter which holds
<a class="reference internal" href="#additional-extra-text">additional extra text</a> to emit when the <tt class="docutils literal"><span class="pre">-help</span></tt> option is invoked, and a
fourth boolean parameter that enables <a class="reference internal" href="#response-files">response files</a>.</p>
</div>
<div class="section" id="the-cl-parseenvironmentoptions-function">
<span id="cl-parseenvironmentoptions"></span><h4>The <tt class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></tt> function<a class="headerlink" href="#the-cl-parseenvironmentoptions-function" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></tt> function has mostly the same effects as
<a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a>, except that it is designed to take values for
options from an environment variable, for those cases in which reading the
command line is not convenient or desired. It fills in the values of all the
command line option variables just like <a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a> does.</p>
<p>It takes four parameters: the name of the program (since <tt class="docutils literal"><span class="pre">argv</span></tt> may not be
available, it can&#8217;t just look in <tt class="docutils literal"><span class="pre">argv[0]</span></tt>), the name of the environment
variable to examine, the optional <a class="reference internal" href="#additional-extra-text">additional extra text</a> to emit when the
<tt class="docutils literal"><span class="pre">-help</span></tt> option is invoked, and the boolean switch that controls whether
<a class="reference internal" href="#response-files">response files</a> should be read.</p>
<p><tt class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></tt> will break the environment variable&#8217;s value up
into words and then process them using <a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a>.
<strong>Note:</strong> Currently <tt class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></tt> does not support quoting, so
an environment variable containing <tt class="docutils literal"><span class="pre">-option</span> <span class="pre">&quot;foo</span> <span class="pre">bar&quot;</span></tt> will be parsed as three
words, <tt class="docutils literal"><span class="pre">-option</span></tt>, <tt class="docutils literal"><span class="pre">&quot;foo</span></tt>, and <tt class="docutils literal"><span class="pre">bar&quot;</span></tt>, which is different from what you
would get from the shell with the same input.</p>
</div>
<div class="section" id="the-cl-setversionprinter-function">
<h4>The <tt class="docutils literal"><span class="pre">cl::SetVersionPrinter</span></tt> function<a class="headerlink" href="#the-cl-setversionprinter-function" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::SetVersionPrinter</span></tt> function is designed to be called directly from
<tt class="docutils literal"><span class="pre">main</span></tt> and <em>before</em> <tt class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></tt>. Its use is optional. It
simply arranges for a function to be called in response to the <tt class="docutils literal"><span class="pre">--version</span></tt>
option instead of having the <tt class="docutils literal"><span class="pre">CommandLine</span></tt> library print out the usual version
string for LLVM. This is useful for programs that are not part of LLVM but wish
to use the <tt class="docutils literal"><span class="pre">CommandLine</span></tt> facilities. Such programs should just define a small
function that takes no arguments and returns <tt class="docutils literal"><span class="pre">void</span></tt> and that prints out
whatever version information is appropriate for the program. Pass the address of
that function to <tt class="docutils literal"><span class="pre">cl::SetVersionPrinter</span></tt> to arrange for it to be called when
the <tt class="docutils literal"><span class="pre">--version</span></tt> option is given by the user.</p>
</div>
<div class="section" id="the-cl-opt-class">
<span id="scalar"></span><span id="cl-opt"></span><h4>The <tt class="docutils literal"><span class="pre">cl::opt</span></tt> class<a class="headerlink" href="#the-cl-opt-class" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::opt</span></tt> class is the class used to represent scalar command line
options, and is the one used most of the time.  It is a templated class which
can take up to three arguments (all except for the first have default values
though):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">DataType</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ExternalStorage</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
            <span class="k">class</span> <span class="nc">ParserClass</span> <span class="o">=</span> <span class="n">parser</span><span class="o">&lt;</span><span class="n">DataType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">opt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first template argument specifies what underlying data type the command line
argument is, and is used to select a default parser implementation.  The second
template argument is used to specify whether the option should contain the
storage for the option (the default) or whether external storage should be used
to contain the value parsed for the option (see <a class="reference internal" href="#internal-vs-external-storage">Internal vs External Storage</a>
for more information).</p>
<p>The third template argument specifies which parser to use.  The default value
selects an instantiation of the <tt class="docutils literal"><span class="pre">parser</span></tt> class based on the underlying data
type of the option.  In general, this default works well for most applications,
so this option is only used when using a <a class="reference internal" href="#custom-parser">custom parser</a>.</p>
</div>
<div class="section" id="the-cl-list-class">
<span id="cl-list"></span><span id="lists-of-arguments"></span><h4>The <tt class="docutils literal"><span class="pre">cl::list</span></tt> class<a class="headerlink" href="#the-cl-list-class" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::list</span></tt> class is the class used to represent a list of command line
options.  It too is a templated class which can take up to three arguments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">DataType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Storage</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">,</span>
            <span class="k">class</span> <span class="nc">ParserClass</span> <span class="o">=</span> <span class="n">parser</span><span class="o">&lt;</span><span class="n">DataType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">list</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This class works the exact same as the <a class="reference internal" href="#cl-opt">cl::opt</a> class, except that the second
argument is the <strong>type</strong> of the external storage, not a boolean value.  For this
class, the marker type &#8216;<tt class="docutils literal"><span class="pre">bool</span></tt>&#8216; is used to indicate that internal storage
should be used.</p>
</div>
<div class="section" id="the-cl-bits-class">
<span id="cl-bits"></span><h4>The <tt class="docutils literal"><span class="pre">cl::bits</span></tt> class<a class="headerlink" href="#the-cl-bits-class" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::bits</span></tt> class is the class used to represent a list of command line
options in the form of a bit vector.  It is also a templated class which can
take up to three arguments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">DataType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Storage</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">,</span>
            <span class="k">class</span> <span class="nc">ParserClass</span> <span class="o">=</span> <span class="n">parser</span><span class="o">&lt;</span><span class="n">DataType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">bits</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This class works the exact same as the <a class="reference internal" href="#cl-list">cl::list</a> class, except that the second
argument must be of <strong>type</strong> <tt class="docutils literal"><span class="pre">unsigned</span></tt> if external storage is used.</p>
</div>
<div class="section" id="the-cl-alias-class">
<span id="cl-alias"></span><h4>The <tt class="docutils literal"><span class="pre">cl::alias</span></tt> class<a class="headerlink" href="#the-cl-alias-class" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::alias</span></tt> class is a nontemplated class that is used to form aliases for
other arguments.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">alias</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#cl-aliasopt">cl::aliasopt</a> attribute should be used to specify which option this is an
alias for.  Alias arguments default to being <a class="reference internal" href="#cl-hidden">cl::Hidden</a>, and use the aliased
options parser to do the conversion from string to data.</p>
</div>
<div class="section" id="the-cl-extrahelp-class">
<span id="cl-extrahelp"></span><h4>The <tt class="docutils literal"><span class="pre">cl::extrahelp</span></tt> class<a class="headerlink" href="#the-cl-extrahelp-class" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">cl::extrahelp</span></tt> class is a nontemplated class that allows extra help text
to be printed out for the <tt class="docutils literal"><span class="pre">-help</span></tt> option.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">extrahelp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To use the extrahelp, simply construct one with a <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt> parameter to
the constructor. The text passed to the constructor will be printed at the
bottom of the help message, verbatim. Note that multiple <tt class="docutils literal"><span class="pre">cl::extrahelp</span></tt>
<strong>can</strong> be used, but this practice is discouraged. If your tool needs to print
additional help information, put all that help into a single <tt class="docutils literal"><span class="pre">cl::extrahelp</span></tt>
instance.</p>
<p>For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cl</span><span class="o">::</span><span class="n">extrahelp</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">ADDITIONAL HELP:</span><span class="se">\n\n</span><span class="s">  This is the extra help</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="builtin-parsers">
<span id="discussed-previously"></span><span id="different-parser"></span><h3>Builtin parsers<a class="headerlink" href="#builtin-parsers" title="Permalink to this headline">¶</a></h3>
<p>Parsers control how the string value taken from the command line is translated
into a typed value, suitable for use in a C++ program.  By default, the
CommandLine library uses an instance of <tt class="docutils literal"><span class="pre">parser&lt;type&gt;</span></tt> if the command line
option specifies that it uses values of type &#8216;<tt class="docutils literal"><span class="pre">type</span></tt>&#8216;.  Because of this,
custom option processing is specified with specializations of the &#8216;<tt class="docutils literal"><span class="pre">parser</span></tt>&#8216;
class.</p>
<p>The CommandLine library provides the following builtin parser specializations,
which are sufficient for most applications. It can, however, also be extended to
work with new data types and new ways of interpreting the same data.  See the
<a class="reference internal" href="#writing-a-custom-parser">Writing a Custom Parser</a> for more details on this type of library extension.</p>
<ul class="simple" id="cl-parser">
<span id="enums"></span><li>The generic <tt class="docutils literal"><span class="pre">parser&lt;t&gt;</span></tt> parser can be used to map strings values to any data
type, through the use of the <a class="reference internal" href="#cl-values">cl::values</a> property, which specifies the
mapping information.  The most common use of this parser is for parsing enum
values, which allows you to use the CommandLine library for all of the error
checking to make sure that only valid enum values are specified (as opposed to
accepting arbitrary strings).  Despite this, however, the generic parser class
can be used for any data type.</li>
</ul>
<ul class="simple" id="bool-parser">
<span id="boolean-flags"></span><li>The <strong>parser&lt;bool&gt; specialization</strong> is used to convert boolean strings to a
boolean value.  Currently accepted strings are &#8220;<tt class="docutils literal"><span class="pre">true</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">TRUE</span></tt>&#8221;,
&#8220;<tt class="docutils literal"><span class="pre">True</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">1</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">false</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">FALSE</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">False</span></tt>&#8221;, and &#8220;<tt class="docutils literal"><span class="pre">0</span></tt>&#8221;.</li>
<li>The <strong>parser&lt;boolOrDefault&gt; specialization</strong> is used for cases where the value
is boolean, but we also need to know whether the option was specified at all.
boolOrDefault is an enum with 3 values, BOU_UNSET, BOU_TRUE and BOU_FALSE.
This parser accepts the same strings as <strong>``parser&lt;bool&gt;``</strong>.</li>
</ul>
<ul class="simple" id="strings">
<li>The <strong>parser&lt;string&gt; specialization</strong> simply stores the parsed string into the
string value specified.  No conversion or modification of the data is
performed.</li>
</ul>
<ul class="simple" id="int">
<span id="integers"></span><li>The <strong>parser&lt;int&gt; specialization</strong> uses the C <tt class="docutils literal"><span class="pre">strtol</span></tt> function to parse the
string input.  As such, it will accept a decimal number (with an optional &#8216;+&#8217;
or &#8216;-&#8216; prefix) which must start with a non-zero digit.  It accepts octal
numbers, which are identified with a &#8216;<tt class="docutils literal"><span class="pre">0</span></tt>&#8216; prefix digit, and hexadecimal
numbers with a prefix of &#8216;<tt class="docutils literal"><span class="pre">0x</span></tt>&#8216; or &#8216;<tt class="docutils literal"><span class="pre">0X</span></tt>&#8216;.</li>
</ul>
<ul class="simple" id="double">
<span id="float"></span><span id="doubles"></span><li>The <strong>parser&lt;double&gt;</strong> and <strong>parser&lt;float&gt; specializations</strong> use the standard
C <tt class="docutils literal"><span class="pre">strtod</span></tt> function to convert floating point strings into floating point
values.  As such, a broad range of string formats is supported, including
exponential notation (ex: <tt class="docutils literal"><span class="pre">1.7e15</span></tt>) and properly supports locales.</li>
</ul>
</div>
</div>
<div class="section" id="extending-the-library">
<span id="extension-guide"></span><span id="id5"></span><h2>Extension Guide<a class="headerlink" href="#extending-the-library" title="Permalink to this headline">¶</a></h2>
<p>Although the CommandLine library has a lot of functionality built into it
already (as discussed previously), one of its true strengths lie in its
extensibility.  This section discusses how the CommandLine library works under
the covers and illustrates how to do some simple, common, extensions.</p>
<div class="section" id="writing-a-custom-parser">
<span id="custom-parser"></span><span id="custom-parsers"></span><span id="id6"></span><h3>Writing a custom parser<a class="headerlink" href="#writing-a-custom-parser" title="Permalink to this headline">¶</a></h3>
<p>One of the simplest and most common extensions is the use of a custom parser.
As <a class="reference internal" href="#discussed-previously">discussed previously</a>, parsers are the portion of the CommandLine library
that turns string input from the user into a particular parsed data type,
validating the input in the process.</p>
<p>There are two ways to use a new parser:</p>
<ol class="arabic">
<li><p class="first">Specialize the <a class="reference internal" href="#cl-parser">cl::parser</a> template for your custom data type.</p>
<p>This approach has the advantage that users of your custom data type will
automatically use your custom parser whenever they define an option with a
value type of your data type.  The disadvantage of this approach is that it
doesn&#8217;t work if your fundamental data type is something that is already
supported.</p>
</li>
<li><p class="first">Write an independent class, using it explicitly from options that need it.</p>
<p>This approach works well in situations where you would line to parse an
option using special syntax for a not-very-special data-type.  The drawback
of this approach is that users of your parser have to be aware that they are
using your parser instead of the builtin ones.</p>
</li>
</ol>
<p>To guide the discussion, we will discuss a custom parser that accepts file
sizes, specified with an optional unit after the numeric size.  For example, we
would like to parse &#8220;102kb&#8221;, &#8220;41M&#8221;, &#8220;1G&#8221; into the appropriate integer value.  In
this case, the underlying data type we want to parse into is &#8216;<tt class="docutils literal"><span class="pre">unsigned</span></tt>&#8216;.  We
choose approach #2 above because we don&#8217;t want to make this the default for all
<tt class="docutils literal"><span class="pre">unsigned</span></tt> options.</p>
<p>To start out, we declare our new <tt class="docutils literal"><span class="pre">FileSizeParser</span></tt> class:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">FileSizeParser</span> <span class="o">:</span> <span class="k">public</span> <span class="n">cl</span><span class="o">::</span><span class="n">basic_parser</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// parse - Return true on error.</span>
  <span class="kt">bool</span> <span class="n">parse</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Option</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ArgName</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">ArgValue</span><span class="p">,</span>
             <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Val</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Our new class inherits from the <tt class="docutils literal"><span class="pre">cl::basic_parser</span></tt> template class to fill in
the default, boiler plate code for us.  We give it the data type that we parse
into, the last argument to the <tt class="docutils literal"><span class="pre">parse</span></tt> method, so that clients of our custom
parser know what object type to pass in to the parse method.  (Here we declare
that we parse into &#8216;<tt class="docutils literal"><span class="pre">unsigned</span></tt>&#8216; variables.)</p>
<p>For most purposes, the only method that must be implemented in a custom parser
is the <tt class="docutils literal"><span class="pre">parse</span></tt> method.  The <tt class="docutils literal"><span class="pre">parse</span></tt> method is called whenever the option is
invoked, passing in the option itself, the option name, the string to parse, and
a reference to a return value.  If the string to parse is not well-formed, the
parser should output an error message and return true.  Otherwise it should
return false and set &#8216;<tt class="docutils literal"><span class="pre">Val</span></tt>&#8216; to the parsed value.  In our example, we
implement <tt class="docutils literal"><span class="pre">parse</span></tt> as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">FileSizeParser</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Option</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ArgName</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Val</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ArgStart</span> <span class="o">=</span> <span class="n">Arg</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">End</span><span class="p">;</span>

  <span class="c1">// Parse integer part, leaving &#39;End&#39; pointing to the first non-integer char</span>
  <span class="n">Val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">strtol</span><span class="p">(</span><span class="n">ArgStart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">End</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">End</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>   <span class="c1">// No error</span>
    <span class="k">case</span> <span class="sc">&#39;i&#39;</span><span class="o">:</span>               <span class="c1">// Ignore the &#39;i&#39; in KiB if people use that</span>
    <span class="k">case</span> <span class="sc">&#39;b&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;B&#39;</span><span class="o">:</span>     <span class="c1">// Ignore B suffix</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="sc">&#39;g&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;G&#39;</span><span class="o">:</span> <span class="n">Val</span> <span class="o">*=</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;m&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;M&#39;</span><span class="o">:</span> <span class="n">Val</span> <span class="o">*=</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;k&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;K&#39;</span><span class="o">:</span> <span class="n">Val</span> <span class="o">*=</span> <span class="mi">1024</span><span class="p">;</span>           <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
      <span class="c1">// Print an error message if unrecognized character!</span>
      <span class="k">return</span> <span class="n">O</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">Arg</span> <span class="o">+</span> <span class="s">&quot;&#39; value invalid for file size argument!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function implements a very simple parser for the kinds of strings we are
interested in.  Although it has some holes (it allows &#8220;<tt class="docutils literal"><span class="pre">123KKK</span></tt>&#8221; for example),
it is good enough for this example.  Note that we use the option itself to print
out the error message (the <tt class="docutils literal"><span class="pre">error</span></tt> method always returns true) in order to get
a nice error message (shown below).  Now that we have our parser class, we can
use it like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="n">FileSizeParser</span><span class="o">&gt;</span>
<span class="n">MFS</span><span class="p">(</span><span class="s">&quot;max-file-size&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Maximum file size to accept&quot;</span><span class="p">),</span>
    <span class="n">cl</span><span class="o">::</span><span class="n">value_desc</span><span class="p">(</span><span class="s">&quot;size&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Which adds this to the output of our program:</p>
<div class="highlight-python"><pre>OPTIONS:
  -help                 - display available options (-help-hidden for more)
  ...
 -max-file-size=&lt;size&gt; - Maximum file size to accept</pre>
</div>
<p>And we can test that our parse works correctly now (the test program just prints
out the max-file-size argument value):</p>
<div class="highlight-python"><pre>$ ./test
MFS: 0
$ ./test -max-file-size=123MB
MFS: 128974848
$ ./test -max-file-size=3G
MFS: 3221225472
$ ./test -max-file-size=dog
-max-file-size option: 'dog' value invalid for file size argument!</pre>
</div>
<p>It looks like it works.  The error message that we get is nice and helpful, and
we seem to accept reasonable file sizes.  This wraps up the &#8220;custom parser&#8221;
tutorial.</p>
</div>
<div class="section" id="exploiting-external-storage">
<h3>Exploiting external storage<a class="headerlink" href="#exploiting-external-storage" title="Permalink to this headline">¶</a></h3>
<p>Several of the LLVM libraries define static <tt class="docutils literal"><span class="pre">cl::opt</span></tt> instances that will
automatically be included in any program that links with that library.  This is
a feature. However, sometimes it is necessary to know the value of the command
line option outside of the library. In these cases the library does or should
provide an external storage location that is accessible to users of the
library. Examples of this include the <tt class="docutils literal"><span class="pre">llvm::DebugFlag</span></tt> exported by the
<tt class="docutils literal"><span class="pre">lib/Support/Debug.cpp</span></tt> file and the <tt class="docutils literal"><span class="pre">llvm::TimePassesIsEnabled</span></tt> flag
exported by the <tt class="docutils literal"><span class="pre">lib/VMCore/PassManager.cpp</span></tt> file.</p>
<p id="dynamically-loaded-options">Dynamically adding command line options</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="CompilerWriterInfo.html" title="Architecture &amp; Platform Information for Compiler Writers"
             >next</a> |</li>
        <li class="right" >
          <a href="CodingStandards.html" title="LLVM Coding Standards"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li><a href="programming.html" >Programming Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, LLVM Project.
      Last updated on 2012-12-21.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>