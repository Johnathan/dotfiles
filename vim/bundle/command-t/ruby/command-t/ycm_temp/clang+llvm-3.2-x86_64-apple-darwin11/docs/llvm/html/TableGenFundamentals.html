

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>TableGen Fundamentals &mdash; LLVM 3.2 documentation</title>
    
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="LLVM 3.2 documentation" href="index.html" />
    <link rel="up" title="Subsystem Documentation" href="subsystems.html" />
    <link rel="next" title="Debugging JIT-ed Code With GDB" href="DebuggingJITedCode.html" />
    <link rel="prev" title="Segmented Stacks in LLVM" href="SegmentedStacks.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="DebuggingJITedCode.html" title="Debugging JIT-ed Code With GDB"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="SegmentedStacks.html" title="Segmented Stacks in LLVM"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li><a href="subsystems.html" accesskey="U">Subsystem Documentation</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">TableGen Fundamentals</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#basic-concepts">Basic concepts</a></li>
<li><a class="reference internal" href="#an-example-record">An example record</a></li>
<li><a class="reference internal" href="#running-tablegen">Running TableGen</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tablegen-syntax">TableGen syntax</a><ul>
<li><a class="reference internal" href="#tablegen-primitives">TableGen primitives</a><ul>
<li><a class="reference internal" href="#tablegen-comments">TableGen comments</a></li>
<li><a class="reference internal" href="#the-tablegen-type-system">The TableGen type system</a></li>
<li><a class="reference internal" href="#tablegen-values-and-expressions">TableGen values and expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#classes-and-definitions">Classes and definitions</a><ul>
<li><a class="reference internal" href="#value-definitions">Value definitions</a></li>
<li><a class="reference internal" href="#let-expressions-within-a-record">&#8216;let&#8217; expressions</a></li>
<li><a class="reference internal" href="#class-template-arguments">Class template arguments</a></li>
<li><a class="reference internal" href="#multiclass-definitions-and-instances">Multiclass definitions and instances</a></li>
</ul>
</li>
<li><a class="reference internal" href="#file-scope-entities">File scope entities</a><ul>
<li><a class="reference internal" href="#file-inclusion">File inclusion</a></li>
<li><a class="reference internal" href="#id3">&#8216;let&#8217; expressions</a></li>
<li><a class="reference internal" href="#looping">Looping</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#code-generator-backend-info">Code Generator backend info</a></li>
<li><a class="reference internal" href="#write-a-backend">TableGen backends</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="SegmentedStacks.html"
                        title="previous chapter">Segmented Stacks in LLVM</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="DebuggingJITedCode.html"
                        title="next chapter">Debugging JIT-ed Code With GDB</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/TableGenFundamentals.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tablegen-fundamentals">
<span id="tablegen"></span><h1>TableGen Fundamentals<a class="headerlink" href="#tablegen-fundamentals" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id5">Introduction</a><ul>
<li><a class="reference internal" href="#basic-concepts" id="id6">Basic concepts</a></li>
<li><a class="reference internal" href="#an-example-record" id="id7">An example record</a></li>
<li><a class="reference internal" href="#running-tablegen" id="id8">Running TableGen</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tablegen-syntax" id="id9">TableGen syntax</a><ul>
<li><a class="reference internal" href="#tablegen-primitives" id="id10">TableGen primitives</a><ul>
<li><a class="reference internal" href="#tablegen-comments" id="id11">TableGen comments</a></li>
<li><a class="reference internal" href="#the-tablegen-type-system" id="id12">The TableGen type system</a></li>
<li><a class="reference internal" href="#tablegen-values-and-expressions" id="id13">TableGen values and expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#classes-and-definitions" id="id14">Classes and definitions</a><ul>
<li><a class="reference internal" href="#value-definitions" id="id15">Value definitions</a></li>
<li><a class="reference internal" href="#let-expressions-within-a-record" id="id16">&#8216;let&#8217; expressions</a></li>
<li><a class="reference internal" href="#class-template-arguments" id="id17">Class template arguments</a></li>
<li><a class="reference internal" href="#multiclass-definitions-and-instances" id="id18">Multiclass definitions and instances</a></li>
</ul>
</li>
<li><a class="reference internal" href="#file-scope-entities" id="id19">File scope entities</a><ul>
<li><a class="reference internal" href="#file-inclusion" id="id20">File inclusion</a></li>
<li><a class="reference internal" href="#id3" id="id21">&#8216;let&#8217; expressions</a></li>
<li><a class="reference internal" href="#looping" id="id22">Looping</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#code-generator-backend-info" id="id23">Code Generator backend info</a></li>
<li><a class="reference internal" href="#write-a-backend" id="id24">TableGen backends</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id5">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>TableGen&#8217;s purpose is to help a human develop and maintain records of
domain-specific information.  Because there may be a large number of these
records, it is specifically designed to allow writing flexible descriptions and
for common features of these records to be factored out.  This reduces the
amount of duplication in the description, reduces the chance of error, and makes
it easier to structure domain specific information.</p>
<p>The core part of TableGen <a class="reference internal" href="#parses-a-file">parses a file</a>, instantiates the declarations, and
hands the result off to a domain-specific <a class="reference internal" href="#tablegen-backend">TableGen backend</a> for processing.
The current major user of TableGen is the <a class="reference external" href="CodeGenerator.html">LLVM code
generator</a>.</p>
<p>Note that if you work on TableGen much, and use emacs or vim, that you can find
an emacs &#8220;TableGen mode&#8221; and a vim language file in the <tt class="docutils literal"><span class="pre">llvm/utils/emacs</span></tt> and
<tt class="docutils literal"><span class="pre">llvm/utils/vim</span></tt> directories of your LLVM distribution, respectively.</p>
<div class="section" id="basic-concepts">
<span id="intro"></span><h3><a class="toc-backref" href="#id6">Basic concepts</a><a class="headerlink" href="#basic-concepts" title="Permalink to this headline">¶</a></h3>
<p>TableGen files consist of two key parts: &#8216;classes&#8217; and &#8216;definitions&#8217;, both of
which are considered &#8216;records&#8217;.</p>
<p><strong>TableGen records</strong> have a unique name, a list of values, and a list of
superclasses.  The list of values is the main data that TableGen builds for each
record; it is this that holds the domain specific information for the
application.  The interpretation of this data is left to a specific <a class="reference internal" href="#tablegen-backend">TableGen
backend</a>, but the structure and format rules are taken care of and are fixed by
TableGen.</p>
<p><strong>TableGen definitions</strong> are the concrete form of &#8216;records&#8217;.  These generally do
not have any undefined values, and are marked with the &#8216;<tt class="docutils literal"><span class="pre">def</span></tt>&#8216; keyword.</p>
<p><strong>TableGen classes</strong> are abstract records that are used to build and describe
other records.  These &#8216;classes&#8217; allow the end-user to build abstractions for
either the domain they are targeting (such as &#8220;Register&#8221;, &#8220;RegisterClass&#8221;, and
&#8220;Instruction&#8221; in the LLVM code generator) or for the implementor to help factor
out common properties of records (such as &#8220;FPInst&#8221;, which is used to represent
floating point instructions in the X86 backend).  TableGen keeps track of all of
the classes that are used to build up a definition, so the backend can find all
definitions of a particular class, such as &#8220;Instruction&#8221;.</p>
<p><strong>TableGen multiclasses</strong> are groups of abstract records that are instantiated
all at once.  Each instantiation can result in multiple TableGen definitions.
If a multiclass inherits from another multiclass, the definitions in the
sub-multiclass become part of the current multiclass, as if they were declared
in the current multiclass.</p>
</div>
<div class="section" id="an-example-record">
<span id="described-above"></span><h3><a class="toc-backref" href="#id7">An example record</a><a class="headerlink" href="#an-example-record" title="Permalink to this headline">¶</a></h3>
<p>With no other arguments, TableGen parses the specified file and prints out all
of the classes, then all of the definitions.  This is a good way to see what the
various definitions expand to fully.  Running this on the <tt class="docutils literal"><span class="pre">X86.td</span></tt> file prints
this (at the time of this writing):</p>
<div class="highlight-llvm"><pre>...
def ADD32rr {   // Instruction X86Inst I
  string Namespace = "X86";
  dag OutOperandList = (outs GR32:$dst);
  dag InOperandList = (ins GR32:$src1, GR32:$src2);
  string AsmString = "add{l}\t{$src2, $dst|$dst, $src2}";
  list&lt;dag&gt; Pattern = [(set GR32:$dst, (add GR32:$src1, GR32:$src2))];
  list&lt;Register&gt; Uses = [];
  list&lt;Register&gt; Defs = [EFLAGS];
  list&lt;Predicate&gt; Predicates = [];
  int CodeSize = 3;
  int AddedComplexity = 0;
  bit isReturn = 0;
  bit isBranch = 0;
  bit isIndirectBranch = 0;
  bit isBarrier = 0;
  bit isCall = 0;
  bit canFoldAsLoad = 0;
  bit mayLoad = 0;
  bit mayStore = 0;
  bit isImplicitDef = 0;
  bit isConvertibleToThreeAddress = 1;
  bit isCommutable = 1;
  bit isTerminator = 0;
  bit isReMaterializable = 0;
  bit isPredicable = 0;
  bit hasDelaySlot = 0;
  bit usesCustomInserter = 0;
  bit hasCtrlDep = 0;
  bit isNotDuplicable = 0;
  bit hasSideEffects = 0;
  bit neverHasSideEffects = 0;
  InstrItinClass Itinerary = NoItinerary;
  string Constraints = "";
  string DisableEncoding = "";
  bits&lt;8&gt; Opcode = { 0, 0, 0, 0, 0, 0, 0, 1 };
  Format Form = MRMDestReg;
  bits&lt;6&gt; FormBits = { 0, 0, 0, 0, 1, 1 };
  ImmType ImmT = NoImm;
  bits&lt;3&gt; ImmTypeBits = { 0, 0, 0 };
  bit hasOpSizePrefix = 0;
  bit hasAdSizePrefix = 0;
  bits&lt;4&gt; Prefix = { 0, 0, 0, 0 };
  bit hasREX_WPrefix = 0;
  FPFormat FPForm = ?;
  bits&lt;3&gt; FPFormBits = { 0, 0, 0 };
}
...</pre>
</div>
<p>This definition corresponds to a 32-bit register-register add instruction in the
X86.  The string after the &#8216;<tt class="docutils literal"><span class="pre">def</span></tt>&#8216; string indicates the name of the
record&#8212;&#8221;<tt class="docutils literal"><span class="pre">ADD32rr</span></tt>&#8221; in this case&#8212;and the comment at the end of the line
indicates the superclasses of the definition.  The body of the record contains
all of the data that TableGen assembled for the record, indicating that the
instruction is part of the &#8220;X86&#8221; namespace, the pattern indicating how the the
instruction should be emitted into the assembly file, that it is a two-address
instruction, has a particular encoding, etc.  The contents and semantics of the
information in the record is specific to the needs of the X86 backend, and is
only shown as an example.</p>
<p>As you can see, a lot of information is needed for every instruction supported
by the code generator, and specifying it all manually would be unmaintainable,
prone to bugs, and tiring to do in the first place.  Because we are using
TableGen, all of the information was derived from the following definition:</p>
<div class="highlight-llvm"><pre>let Defs = [EFLAGS],
    isCommutable = 1,                  // X = ADD Y,Z --&gt; X = ADD Z,Y
    isConvertibleToThreeAddress = 1 in // Can transform into LEA.
def ADD32rr  : I&lt;0x01, MRMDestReg, (outs GR32:$dst),
                                   (ins GR32:$src1, GR32:$src2),
                 "add{l}\t{$src2, $dst|$dst, $src2}",
                 [(set GR32:$dst, (add GR32:$src1, GR32:$src2))]&gt;;</pre>
</div>
<p>This definition makes use of the custom class <tt class="docutils literal"><span class="pre">I</span></tt> (extended from the custom
class <tt class="docutils literal"><span class="pre">X86Inst</span></tt>), which is defined in the X86-specific TableGen file, to
factor out the common features that instructions of its class share.  A key
feature of TableGen is that it allows the end-user to define the abstractions
they prefer to use when describing their information.</p>
<p>Each def record has a special entry called &#8220;<tt class="docutils literal"><span class="pre">NAME</span></tt>.&#8221;  This is the name of the
def (&#8220;<tt class="docutils literal"><span class="pre">ADD32rr</span></tt>&#8221; above).  In the general case def names can be formed from
various kinds of string processing expressions and <tt class="docutils literal"><span class="pre">NAME</span></tt> resolves to the
final value obtained after resolving all of those expressions.  The user may
refer to <tt class="docutils literal"><span class="pre">NAME</span></tt> anywhere she desires to use the ultimate name of the def.
<tt class="docutils literal"><span class="pre">NAME</span></tt> should not be defined anywhere else in user code to avoid conflict
problems.</p>
</div>
<div class="section" id="running-tablegen">
<h3><a class="toc-backref" href="#id8">Running TableGen</a><a class="headerlink" href="#running-tablegen" title="Permalink to this headline">¶</a></h3>
<p>TableGen runs just like any other LLVM tool.  The first (optional) argument
specifies the file to read.  If a filename is not specified, <tt class="docutils literal"><span class="pre">llvm-tblgen</span></tt>
reads from standard input.</p>
<p>To be useful, one of the <a class="reference internal" href="#tablegen-backends">TableGen backends</a> must be used.  These backends are
selectable on the command line (type &#8216;<tt class="docutils literal"><span class="pre">llvm-tblgen</span> <span class="pre">-help</span></tt>&#8216; for a list).  For
example, to get a list of all of the definitions that subclass a particular type
(which can be useful for building up an enum list of these records), use the
<tt class="docutils literal"><span class="pre">-print-enums</span></tt> option:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>llvm-tblgen X86.td -print-enums -class<span class="o">=</span>Register
AH, AL, AX, BH, BL, BP, BPL, BX, CH, CL, CX, DH, DI, DIL, DL, DX, EAX, EBP, EBX,
ECX, EDI, EDX, EFLAGS, EIP, ESI, ESP, FP0, FP1, FP2, FP3, FP4, FP5, FP6, IP,
MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7, R10, R10B, R10D, R10W, R11, R11B, R11D,
R11W, R12, R12B, R12D, R12W, R13, R13B, R13D, R13W, R14, R14B, R14D, R14W, R15,
R15B, R15D, R15W, R8, R8B, R8D, R8W, R9, R9B, R9D, R9W, RAX, RBP, RBX, RCX, RDI,
RDX, RIP, RSI, RSP, SI, SIL, SP, SPL, ST0, ST1, ST2, ST3, ST4, ST5, ST6, ST7,
XMM0, XMM1, XMM10, XMM11, XMM12, XMM13, XMM14, XMM15, XMM2, XMM3, XMM4, XMM5,
XMM6, XMM7, XMM8, XMM9,

<span class="nv">$ </span>llvm-tblgen X86.td -print-enums -class<span class="o">=</span>Instruction
ABS_F, ABS_Fp32, ABS_Fp64, ABS_Fp80, ADC32mi, ADC32mi8, ADC32mr, ADC32ri,
ADC32ri8, ADC32rm, ADC32rr, ADC64mi32, ADC64mi8, ADC64mr, ADC64ri32, ADC64ri8,
ADC64rm, ADC64rr, ADD16mi, ADD16mi8, ADD16mr, ADD16ri, ADD16ri8, ADD16rm,
ADD16rr, ADD32mi, ADD32mi8, ADD32mr, ADD32ri, ADD32ri8, ADD32rm, ADD32rr,
ADD64mi32, ADD64mi8, ADD64mr, ADD64ri32, ...
</pre></div>
</div>
<p>The default backend prints out all of the records, as <a class="reference internal" href="#described-above">described above</a>.</p>
<p>If you plan to use TableGen, you will most likely have to <a class="reference internal" href="#write-a-backend">write a backend</a>
that extracts the information specific to what you need and formats it in the
appropriate way.</p>
</div>
</div>
<div class="section" id="tablegen-syntax">
<span id="parses-a-file"></span><h2><a class="toc-backref" href="#id9">TableGen syntax</a><a class="headerlink" href="#tablegen-syntax" title="Permalink to this headline">¶</a></h2>
<p>TableGen doesn&#8217;t care about the meaning of data (that is up to the backend to
define), but it does care about syntax, and it enforces a simple type system.
This section describes the syntax and the constructs allowed in a TableGen file.</p>
<div class="section" id="tablegen-primitives">
<h3><a class="toc-backref" href="#id10">TableGen primitives</a><a class="headerlink" href="#tablegen-primitives" title="Permalink to this headline">¶</a></h3>
<div class="section" id="tablegen-comments">
<h4><a class="toc-backref" href="#id11">TableGen comments</a><a class="headerlink" href="#tablegen-comments" title="Permalink to this headline">¶</a></h4>
<p>TableGen supports BCPL style &#8220;<tt class="docutils literal"><span class="pre">//</span></tt>&#8221; comments, which run to the end of the
line, and it also supports <strong>nestable</strong> &#8220;<tt class="docutils literal"><span class="pre">/*</span> <span class="pre">*/</span></tt>&#8221; comments.</p>
</div>
<div class="section" id="the-tablegen-type-system">
<span id="tablegen-type"></span><h4><a class="toc-backref" href="#id12">The TableGen type system</a><a class="headerlink" href="#the-tablegen-type-system" title="Permalink to this headline">¶</a></h4>
<p>TableGen files are strongly typed, in a simple (but complete) type-system.
These types are used to perform automatic conversions, check for errors, and to
help interface designers constrain the input that they allow.  Every <a class="reference internal" href="#value-definition">value
definition</a> is required to have an associated type.</p>
<p>TableGen supports a mixture of very low-level types (such as <tt class="docutils literal"><span class="pre">bit</span></tt>) and very
high-level types (such as <tt class="docutils literal"><span class="pre">dag</span></tt>).  This flexibility is what allows it to
describe a wide range of information conveniently and compactly.  The TableGen
types are:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">bit</span></tt></dt>
<dd>A &#8216;bit&#8217; is a boolean value that can hold either 0 or 1.</dd>
<dt><tt class="docutils literal"><span class="pre">int</span></tt></dt>
<dd>The &#8216;int&#8217; type represents a simple 32-bit integer value, such as 5.</dd>
<dt><tt class="docutils literal"><span class="pre">string</span></tt></dt>
<dd>The &#8216;string&#8217; type represents an ordered sequence of characters of arbitrary
length.</dd>
<dt><tt class="docutils literal"><span class="pre">bits&lt;n&gt;</span></tt></dt>
<dd>A &#8216;bits&#8217; type is an arbitrary, but fixed, size integer that is broken up
into individual bits.  This type is useful because it can handle some bits
being defined while others are undefined.</dd>
<dt><tt class="docutils literal"><span class="pre">list&lt;ty&gt;</span></tt></dt>
<dd>This type represents a list whose elements are some other type.  The
contained type is arbitrary: it can even be another list type.</dd>
<dt>Class type</dt>
<dd>Specifying a class name in a type context means that the defined value must
be a subclass of the specified class.  This is useful in conjunction with
the <tt class="docutils literal"><span class="pre">list</span></tt> type, for example, to constrain the elements of the list to a
common base class (e.g., a <tt class="docutils literal"><span class="pre">list&lt;Register&gt;</span></tt> can only contain definitions
derived from the &#8220;<tt class="docutils literal"><span class="pre">Register</span></tt>&#8221; class).</dd>
<dt><tt class="docutils literal"><span class="pre">dag</span></tt></dt>
<dd>This type represents a nestable directed graph of elements.</dd>
<dt><tt class="docutils literal"><span class="pre">code</span></tt></dt>
<dd>This represents a big hunk of text.  This is lexically distinct from string
values because it doesn&#8217;t require escaping double quotes and other common
characters that occur in code.</dd>
</dl>
<p>To date, these types have been sufficient for describing things that TableGen
has been used for, but it is straight-forward to extend this list if needed.</p>
</div>
<div class="section" id="tablegen-values-and-expressions">
<span id="tablegen-expressions"></span><h4><a class="toc-backref" href="#id13">TableGen values and expressions</a><a class="headerlink" href="#tablegen-values-and-expressions" title="Permalink to this headline">¶</a></h4>
<p>TableGen allows for a pretty reasonable number of different expression forms
when building up values.  These forms allow the TableGen file to be written in a
natural syntax and flavor for the application.  The current expression forms
supported include:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">?</span></tt></dt>
<dd>uninitialized field</dd>
<dt><tt class="docutils literal"><span class="pre">0b1001011</span></tt></dt>
<dd>binary integer value</dd>
<dt><tt class="docutils literal"><span class="pre">07654321</span></tt></dt>
<dd>octal integer value (indicated by a leading 0)</dd>
<dt><tt class="docutils literal"><span class="pre">7</span></tt></dt>
<dd>decimal integer value</dd>
<dt><tt class="docutils literal"><span class="pre">0x7F</span></tt></dt>
<dd>hexadecimal integer value</dd>
<dt><tt class="docutils literal"><span class="pre">&quot;foo&quot;</span></tt></dt>
<dd>string value</dd>
<dt><tt class="docutils literal"><span class="pre">[{</span> <span class="pre">...</span> <span class="pre">}]</span></tt></dt>
<dd>code fragment</dd>
<dt><tt class="docutils literal"><span class="pre">[</span> <span class="pre">X,</span> <span class="pre">Y,</span> <span class="pre">Z</span> <span class="pre">]&lt;type&gt;</span></tt></dt>
<dd>list value.  &lt;type&gt; is the type of the list element and is usually optional.
In rare cases, TableGen is unable to deduce the element type in which case
the user must specify it explicitly.</dd>
<dt><tt class="docutils literal"><span class="pre">{</span> <span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span> <span class="pre">}</span></tt></dt>
<dd>initializer for a &#8220;bits&lt;3&gt;&#8221; value</dd>
<dt><tt class="docutils literal"><span class="pre">value</span></tt></dt>
<dd>value reference</dd>
<dt><tt class="docutils literal"><span class="pre">value{17}</span></tt></dt>
<dd>access to one bit of a value</dd>
<dt><tt class="docutils literal"><span class="pre">value{15-17}</span></tt></dt>
<dd>access to multiple bits of a value</dd>
<dt><tt class="docutils literal"><span class="pre">DEF</span></tt></dt>
<dd>reference to a record definition</dd>
<dt><tt class="docutils literal"><span class="pre">CLASS&lt;val</span> <span class="pre">list&gt;</span></tt></dt>
<dd>reference to a new anonymous definition of CLASS with the specified template
arguments.</dd>
<dt><tt class="docutils literal"><span class="pre">X.Y</span></tt></dt>
<dd>reference to the subfield of a value</dd>
<dt><tt class="docutils literal"><span class="pre">list[4-7,17,2-3]</span></tt></dt>
<dd>A slice of the &#8216;list&#8217; list, including elements 4,5,6,7,17,2, and 3 from it.
Elements may be included multiple times.</dd>
</dl>
<p><tt class="docutils literal"><span class="pre">foreach</span> <span class="pre">&lt;var&gt;</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">&lt;list&gt;</span> <span class="pre">]</span> <span class="pre">in</span> <span class="pre">{</span> <span class="pre">&lt;body&gt;</span> <span class="pre">}</span></tt></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">foreach</span> <span class="pre">&lt;var&gt;</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">&lt;list&gt;</span> <span class="pre">]</span> <span class="pre">in</span> <span class="pre">&lt;def&gt;</span></tt></dt>
<dd>Replicate &lt;body&gt; or &lt;def&gt;, replacing instances of &lt;var&gt; with each value
in &lt;list&gt;.  &lt;var&gt; is scoped at the level of the <tt class="docutils literal"><span class="pre">foreach</span></tt> loop and must
not conflict with any other object introduced in &lt;body&gt; or &lt;def&gt;.  Currently
only <tt class="docutils literal"><span class="pre">def</span></tt>s are expanded within &lt;body&gt;.</dd>
</dl>
<p><tt class="docutils literal"><span class="pre">foreach</span> <span class="pre">&lt;var&gt;</span> <span class="pre">=</span> <span class="pre">0-15</span> <span class="pre">in</span> <span class="pre">...</span></tt></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">foreach</span> <span class="pre">&lt;var&gt;</span> <span class="pre">=</span> <span class="pre">{0-15,32-47}</span> <span class="pre">in</span> <span class="pre">...</span></tt></dt>
<dd>Loop over ranges of integers. The braces are required for multiple ranges.</dd>
<dt><tt class="docutils literal"><span class="pre">(DEF</span> <span class="pre">a,</span> <span class="pre">b)</span></tt></dt>
<dd>a dag value.  The first element is required to be a record definition, the
remaining elements in the list may be arbitrary other values, including
nested <tt class="docutils literal"><span class="pre">`dag</span></tt>&#8216; values.</dd>
<dt><tt class="docutils literal"><span class="pre">!strconcat(a,</span> <span class="pre">b)</span></tt></dt>
<dd>A string value that is the result of concatenating the &#8216;a&#8217; and &#8216;b&#8217; strings.</dd>
<dt><tt class="docutils literal"><span class="pre">str1#str2</span></tt></dt>
<dd>&#8220;#&#8221; (paste) is a shorthand for !strconcat.  It may concatenate things that
are not quoted strings, in which case an implicit !cast&lt;string&gt; is done on
the operand of the paste.</dd>
<dt><tt class="docutils literal"><span class="pre">!cast&lt;type&gt;(a)</span></tt></dt>
<dd>A symbol of type <em>type</em> obtained by looking up the string &#8216;a&#8217; in the symbol
table.  If the type of &#8216;a&#8217; does not match <em>type</em>, TableGen aborts with an
error. !cast&lt;string&gt; is a special case in that the argument must be an
object defined by a &#8216;def&#8217; construct.</dd>
<dt><tt class="docutils literal"><span class="pre">!subst(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></tt></dt>
<dd>If &#8216;a&#8217; and &#8216;b&#8217; are of string type or are symbol references, substitute &#8216;b&#8217;
for &#8216;a&#8217; in &#8216;c.&#8217;  This operation is analogous to $(subst) in GNU make.</dd>
<dt><tt class="docutils literal"><span class="pre">!foreach(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></tt></dt>
<dd>For each member &#8216;b&#8217; of dag or list &#8216;a&#8217; apply operator &#8216;c.&#8217;  &#8216;b&#8217; is a dummy
variable that should be declared as a member variable of an instantiated
class.  This operation is analogous to $(foreach) in GNU make.</dd>
<dt><tt class="docutils literal"><span class="pre">!head(a)</span></tt></dt>
<dd>The first element of list &#8216;a.&#8217;</dd>
<dt><tt class="docutils literal"><span class="pre">!tail(a)</span></tt></dt>
<dd>The 2nd-N elements of list &#8216;a.&#8217;</dd>
<dt><tt class="docutils literal"><span class="pre">!empty(a)</span></tt></dt>
<dd>An integer {0,1} indicating whether list &#8216;a&#8217; is empty.</dd>
<dt><tt class="docutils literal"><span class="pre">!if(a,b,c)</span></tt></dt>
<dd>&#8216;b&#8217; if the result of &#8216;int&#8217; or &#8216;bit&#8217; operator &#8216;a&#8217; is nonzero, &#8216;c&#8217; otherwise.</dd>
<dt><tt class="docutils literal"><span class="pre">!eq(a,b)</span></tt></dt>
<dd>&#8216;bit 1&#8217; if string a is equal to string b, 0 otherwise.  This only operates
on string, int and bit objects.  Use !cast&lt;string&gt; to compare other types of
objects.</dd>
</dl>
<p>Note that all of the values have rules specifying how they convert to values
for different types.  These rules allow you to assign a value like &#8220;<tt class="docutils literal"><span class="pre">7</span></tt>&#8221;
to a &#8220;<tt class="docutils literal"><span class="pre">bits&lt;4&gt;</span></tt>&#8221; value, for example.</p>
</div>
</div>
<div class="section" id="classes-and-definitions">
<h3><a class="toc-backref" href="#id14">Classes and definitions</a><a class="headerlink" href="#classes-and-definitions" title="Permalink to this headline">¶</a></h3>
<p>As mentioned in the <a class="reference internal" href="#intro">intro</a>, classes and definitions (collectively known as
&#8216;records&#8217;) in TableGen are the main high-level unit of information that TableGen
collects.  Records are defined with a <tt class="docutils literal"><span class="pre">def</span></tt> or <tt class="docutils literal"><span class="pre">class</span></tt> keyword, the record
name, and an optional list of &#8220;<a class="reference internal" href="#template-arguments">template arguments</a>&#8221;.  If the record has
superclasses, they are specified as a comma separated list that starts with a
colon character (&#8220;<tt class="docutils literal"><span class="pre">:</span></tt>&#8221;).  If <a class="reference internal" href="#value-definitions">value definitions</a> or <a class="reference internal" href="#let-expressions">let expressions</a> are
needed for the class, they are enclosed in curly braces (&#8220;<tt class="docutils literal"><span class="pre">{}</span></tt>&#8221;); otherwise,
the record ends with a semicolon.</p>
<p>Here is a simple TableGen file:</p>
<div class="highlight-llvm"><pre>class C { bit V = 1; }
def X : C;
def Y : C {
  string Greeting = "hello";
}</pre>
</div>
<p>This example defines two definitions, <tt class="docutils literal"><span class="pre">X</span></tt> and <tt class="docutils literal"><span class="pre">Y</span></tt>, both of which derive from
the <tt class="docutils literal"><span class="pre">C</span></tt> class.  Because of this, they both get the <tt class="docutils literal"><span class="pre">V</span></tt> bit value.  The <tt class="docutils literal"><span class="pre">Y</span></tt>
definition also gets the Greeting member as well.</p>
<p>In general, classes are useful for collecting together the commonality between a
group of records and isolating it in a single place.  Also, classes permit the
specification of default values for their subclasses, allowing the subclasses to
override them as they wish.</p>
<div class="section" id="value-definitions">
<span id="value-definition"></span><span id="id1"></span><h4><a class="toc-backref" href="#id15">Value definitions</a><a class="headerlink" href="#value-definitions" title="Permalink to this headline">¶</a></h4>
<p>Value definitions define named entries in records.  A value must be defined
before it can be referred to as the operand for another value definition or
before the value is reset with a <a class="reference internal" href="#let-expression">let expression</a>.  A value is defined by
specifying a <a class="reference internal" href="#tablegen-type">TableGen type</a> and a name.  If an initial value is available, it
may be specified after the type with an equal sign.  Value definitions require
terminating semicolons.</p>
</div>
<div class="section" id="let-expressions-within-a-record">
<span id="let-expressions"></span><span id="let-expression"></span><span id="id2"></span><h4><a class="toc-backref" href="#id16">&#8216;let&#8217; expressions</a><a class="headerlink" href="#let-expressions-within-a-record" title="Permalink to this headline">¶</a></h4>
<p>A record-level let expression is used to change the value of a value definition
in a record.  This is primarily useful when a superclass defines a value that a
derived class or definition wants to override.  Let expressions consist of the
&#8216;<tt class="docutils literal"><span class="pre">let</span></tt>&#8216; keyword followed by a value name, an equal sign (&#8220;<tt class="docutils literal"><span class="pre">=</span></tt>&#8221;), and a new
value.  For example, a new class could be added to the example above, redefining
the <tt class="docutils literal"><span class="pre">V</span></tt> field for all of its subclasses:</p>
<div class="highlight-llvm"><pre>class D : C { let V = 0; }
def Z : D;</pre>
</div>
<p>In this case, the <tt class="docutils literal"><span class="pre">Z</span></tt> definition will have a zero value for its <tt class="docutils literal"><span class="pre">V</span></tt> value,
despite the fact that it derives (indirectly) from the <tt class="docutils literal"><span class="pre">C</span></tt> class, because the
<tt class="docutils literal"><span class="pre">D</span></tt> class overrode its value.</p>
</div>
<div class="section" id="class-template-arguments">
<span id="template-arguments"></span><h4><a class="toc-backref" href="#id17">Class template arguments</a><a class="headerlink" href="#class-template-arguments" title="Permalink to this headline">¶</a></h4>
<p>TableGen permits the definition of parameterized classes as well as normal
concrete classes.  Parameterized TableGen classes specify a list of variable
bindings (which may optionally have defaults) that are bound when used.  Here is
a simple example:</p>
<div class="highlight-llvm"><pre>class FPFormat&lt;bits&lt;3&gt; val&gt; {
  bits&lt;3&gt; Value = val;
}
def NotFP      : FPFormat&lt;0&gt;;
def ZeroArgFP  : FPFormat&lt;1&gt;;
def OneArgFP   : FPFormat&lt;2&gt;;
def OneArgFPRW : FPFormat&lt;3&gt;;
def TwoArgFP   : FPFormat&lt;4&gt;;
def CompareFP  : FPFormat&lt;5&gt;;
def CondMovFP  : FPFormat&lt;6&gt;;
def SpecialFP  : FPFormat&lt;7&gt;;</pre>
</div>
<p>In this case, template arguments are used as a space efficient way to specify a
list of &#8220;enumeration values&#8221;, each with a &#8220;<tt class="docutils literal"><span class="pre">Value</span></tt>&#8221; field set to the specified
integer.</p>
<p>The more esoteric forms of <a class="reference internal" href="#tablegen-expressions">TableGen expressions</a> are useful in conjunction
with template arguments.  As an example:</p>
<div class="highlight-llvm"><pre>class ModRefVal&lt;bits&lt;2&gt; val&gt; {
  bits&lt;2&gt; Value = val;
}

def None   : ModRefVal&lt;0&gt;;
def Mod    : ModRefVal&lt;1&gt;;
def Ref    : ModRefVal&lt;2&gt;;
def ModRef : ModRefVal&lt;3&gt;;

class Value&lt;ModRefVal MR&gt; {
  // Decode some information into a more convenient format, while providing
  // a nice interface to the user of the "Value" class.
  bit isMod = MR.Value{0};
  bit isRef = MR.Value{1};

  // other stuff...
}

// Example uses
def bork : Value&lt;Mod&gt;;
def zork : Value&lt;Ref&gt;;
def hork : Value&lt;ModRef&gt;;</pre>
</div>
<p>This is obviously a contrived example, but it shows how template arguments can
be used to decouple the interface provided to the user of the class from the
actual internal data representation expected by the class.  In this case,
running <tt class="docutils literal"><span class="pre">llvm-tblgen</span></tt> on the example prints the following definitions:</p>
<div class="highlight-llvm"><pre>def bork {      // Value
  bit isMod = 1;
  bit isRef = 0;
}
def hork {      // Value
  bit isMod = 1;
  bit isRef = 1;
}
def zork {      // Value
  bit isMod = 0;
  bit isRef = 1;
}</pre>
</div>
<p>This shows that TableGen was able to dig into the argument and extract a piece
of information that was requested by the designer of the &#8220;Value&#8221; class.  For
more realistic examples, please see existing users of TableGen, such as the X86
backend.</p>
</div>
<div class="section" id="multiclass-definitions-and-instances">
<h4><a class="toc-backref" href="#id18">Multiclass definitions and instances</a><a class="headerlink" href="#multiclass-definitions-and-instances" title="Permalink to this headline">¶</a></h4>
<p>While classes with template arguments are a good way to factor commonality
between two instances of a definition, multiclasses allow a convenient notation
for defining multiple definitions at once (instances of implicitly constructed
classes).  For example, consider an 3-address instruction set whose instructions
come in two forms: &#8220;<tt class="docutils literal"><span class="pre">reg</span> <span class="pre">=</span> <span class="pre">reg</span> <span class="pre">op</span> <span class="pre">reg</span></tt>&#8221; and &#8220;<tt class="docutils literal"><span class="pre">reg</span> <span class="pre">=</span> <span class="pre">reg</span> <span class="pre">op</span> <span class="pre">imm</span></tt>&#8221;
(e.g. SPARC). In this case, you&#8217;d like to specify in one place that this
commonality exists, then in a separate place indicate what all the ops are.</p>
<p>Here is an example TableGen fragment that shows this idea:</p>
<div class="highlight-llvm"><pre>def ops;
def GPR;
def Imm;
class inst&lt;int opc, string asmstr, dag operandlist&gt;;

multiclass ri_inst&lt;int opc, string asmstr&gt; {
  def _rr : inst&lt;opc, !strconcat(asmstr, " $dst, $src1, $src2"),
                 (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;;
  def _ri : inst&lt;opc, !strconcat(asmstr, " $dst, $src1, $src2"),
                 (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;;
}

// Instantiations of the ri_inst multiclass.
defm ADD : ri_inst&lt;0b111, "add"&gt;;
defm SUB : ri_inst&lt;0b101, "sub"&gt;;
defm MUL : ri_inst&lt;0b100, "mul"&gt;;
...</pre>
</div>
<p>The name of the resultant definitions has the multidef fragment names appended
to them, so this defines <tt class="docutils literal"><span class="pre">ADD_rr</span></tt>, <tt class="docutils literal"><span class="pre">ADD_ri</span></tt>, <tt class="docutils literal"><span class="pre">SUB_rr</span></tt>, etc.  A defm may
inherit from multiple multiclasses, instantiating definitions from each
multiclass.  Using a multiclass this way is exactly equivalent to instantiating
the classes multiple times yourself, e.g. by writing:</p>
<div class="highlight-llvm"><pre>def ops;
def GPR;
def Imm;
class inst&lt;int opc, string asmstr, dag operandlist&gt;;

class rrinst&lt;int opc, string asmstr&gt;
  : inst&lt;opc, !strconcat(asmstr, " $dst, $src1, $src2"),
         (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;;

class riinst&lt;int opc, string asmstr&gt;
  : inst&lt;opc, !strconcat(asmstr, " $dst, $src1, $src2"),
         (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;;

// Instantiations of the ri_inst multiclass.
def ADD_rr : rrinst&lt;0b111, "add"&gt;;
def ADD_ri : riinst&lt;0b111, "add"&gt;;
def SUB_rr : rrinst&lt;0b101, "sub"&gt;;
def SUB_ri : riinst&lt;0b101, "sub"&gt;;
def MUL_rr : rrinst&lt;0b100, "mul"&gt;;
def MUL_ri : riinst&lt;0b100, "mul"&gt;;
...</pre>
</div>
<p>A <tt class="docutils literal"><span class="pre">defm</span></tt> can also be used inside a multiclass providing several levels of
multiclass instanciations.</p>
<div class="highlight-llvm"><pre>class Instruction&lt;bits&lt;4&gt; opc, string Name&gt; {
  bits&lt;4&gt; opcode = opc;
  string name = Name;
}

multiclass basic_r&lt;bits&lt;4&gt; opc&gt; {
  def rr : Instruction&lt;opc, "rr"&gt;;
  def rm : Instruction&lt;opc, "rm"&gt;;
}

multiclass basic_s&lt;bits&lt;4&gt; opc&gt; {
  defm SS : basic_r&lt;opc&gt;;
  defm SD : basic_r&lt;opc&gt;;
  def X : Instruction&lt;opc, "x"&gt;;
}

multiclass basic_p&lt;bits&lt;4&gt; opc&gt; {
  defm PS : basic_r&lt;opc&gt;;
  defm PD : basic_r&lt;opc&gt;;
  def Y : Instruction&lt;opc, "y"&gt;;
}

defm ADD : basic_s&lt;0xf&gt;, basic_p&lt;0xf&gt;;
...

// Results
def ADDPDrm { ...
def ADDPDrr { ...
def ADDPSrm { ...
def ADDPSrr { ...
def ADDSDrm { ...
def ADDSDrr { ...
def ADDY { ...
def ADDX { ...</pre>
</div>
<p><tt class="docutils literal"><span class="pre">defm</span></tt> declarations can inherit from classes too, the rule to follow is that
the class list must start after the last multiclass, and there must be at least
one multiclass before them.</p>
<div class="highlight-llvm"><pre>class XD { bits&lt;4&gt; Prefix = 11; }
class XS { bits&lt;4&gt; Prefix = 12; }

class I&lt;bits&lt;4&gt; op&gt; {
  bits&lt;4&gt; opcode = op;
}

multiclass R {
  def rr : I&lt;4&gt;;
  def rm : I&lt;2&gt;;
}

multiclass Y {
  defm SS : R, XD;
  defm SD : R, XS;
}

defm Instr : Y;

// Results
def InstrSDrm {
  bits&lt;4&gt; opcode = { 0, 0, 1, 0 };
  bits&lt;4&gt; Prefix = { 1, 1, 0, 0 };
}
...
def InstrSSrr {
  bits&lt;4&gt; opcode = { 0, 1, 0, 0 };
  bits&lt;4&gt; Prefix = { 1, 0, 1, 1 };
}</pre>
</div>
</div>
</div>
<div class="section" id="file-scope-entities">
<h3><a class="toc-backref" href="#id19">File scope entities</a><a class="headerlink" href="#file-scope-entities" title="Permalink to this headline">¶</a></h3>
<div class="section" id="file-inclusion">
<h4><a class="toc-backref" href="#id20">File inclusion</a><a class="headerlink" href="#file-inclusion" title="Permalink to this headline">¶</a></h4>
<p>TableGen supports the &#8216;<tt class="docutils literal"><span class="pre">include</span></tt>&#8216; token, which textually substitutes the
specified file in place of the include directive.  The filename should be
specified as a double quoted string immediately after the &#8216;<tt class="docutils literal"><span class="pre">include</span></tt>&#8216; keyword.
Example:</p>
<div class="highlight-llvm"><pre>include "foo.td"</pre>
</div>
</div>
<div class="section" id="id3">
<h4><a class="toc-backref" href="#id21">&#8216;let&#8217; expressions</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>&#8220;Let&#8221; expressions at file scope are similar to <a class="reference internal" href="#let-expressions-within-a-record">&#8220;let&#8221; expressions within a
record</a>, except they can specify a value binding for multiple records at a
time, and may be useful in certain other cases.  File-scope let expressions are
really just another way that TableGen allows the end-user to factor out
commonality from the records.</p>
<p>File-scope &#8220;let&#8221; expressions take a comma-separated list of bindings to apply,
and one or more records to bind the values in.  Here are some examples:</p>
<div class="highlight-llvm"><pre>let isTerminator = 1, isReturn = 1, isBarrier = 1, hasCtrlDep = 1 in
  def RET : I&lt;0xC3, RawFrm, (outs), (ins), "ret", [(X86retflag 0)]&gt;;

let isCall = 1 in
  // All calls clobber the non-callee saved registers...
  let Defs = [EAX, ECX, EDX, FP0, FP1, FP2, FP3, FP4, FP5, FP6, ST0,
              MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7,
              XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7, EFLAGS] in {
    def CALLpcrel32 : Ii32&lt;0xE8, RawFrm, (outs), (ins i32imm:$dst,variable_ops),
                           "call\t${dst:call}", []&gt;;
    def CALL32r     : I&lt;0xFF, MRM2r, (outs), (ins GR32:$dst, variable_ops),
                        "call\t{*}$dst", [(X86call GR32:$dst)]&gt;;
    def CALL32m     : I&lt;0xFF, MRM2m, (outs), (ins i32mem:$dst, variable_ops),
                        "call\t{*}$dst", []&gt;;
  }</pre>
</div>
<p>File-scope &#8220;let&#8221; expressions are often useful when a couple of definitions need
to be added to several records, and the records do not otherwise need to be
opened, as in the case with the <tt class="docutils literal"><span class="pre">CALL*</span></tt> instructions above.</p>
<p>It&#8217;s also possible to use &#8220;let&#8221; expressions inside multiclasses, providing more
ways to factor out commonality from the records, specially if using several
levels of multiclass instanciations. This also avoids the need of using &#8220;let&#8221;
expressions within subsequent records inside a multiclass.</p>
<div class="highlight-llvm"><pre>multiclass basic_r&lt;bits&lt;4&gt; opc&gt; {
  let Predicates = [HasSSE2] in {
    def rr : Instruction&lt;opc, "rr"&gt;;
    def rm : Instruction&lt;opc, "rm"&gt;;
  }
  let Predicates = [HasSSE3] in
    def rx : Instruction&lt;opc, "rx"&gt;;
}

multiclass basic_ss&lt;bits&lt;4&gt; opc&gt; {
  let IsDouble = 0 in
    defm SS : basic_r&lt;opc&gt;;

  let IsDouble = 1 in
    defm SD : basic_r&lt;opc&gt;;
}

defm ADD : basic_ss&lt;0xf&gt;;</pre>
</div>
</div>
<div class="section" id="looping">
<h4><a class="toc-backref" href="#id22">Looping</a><a class="headerlink" href="#looping" title="Permalink to this headline">¶</a></h4>
<p>TableGen supports the &#8216;<tt class="docutils literal"><span class="pre">foreach</span></tt>&#8216; block, which textually replicates the loop
body, substituting iterator values for iterator references in the body.
Example:</p>
<div class="highlight-llvm"><pre>foreach i = [0, 1, 2, 3] in {
  def R#i : Register&lt;...&gt;;
  def F#i : Register&lt;...&gt;;
}</pre>
</div>
<p>This will create objects <tt class="docutils literal"><span class="pre">R0</span></tt>, <tt class="docutils literal"><span class="pre">R1</span></tt>, <tt class="docutils literal"><span class="pre">R2</span></tt> and <tt class="docutils literal"><span class="pre">R3</span></tt>.  <tt class="docutils literal"><span class="pre">foreach</span></tt> blocks
may be nested. If there is only one item in the body the braces may be
elided:</p>
<div class="highlight-llvm"><pre>foreach i = [0, 1, 2, 3] in
  def R#i : Register&lt;...&gt;;</pre>
</div>
</div>
</div>
</div>
<div class="section" id="code-generator-backend-info">
<h2><a class="toc-backref" href="#id23">Code Generator backend info</a><a class="headerlink" href="#code-generator-backend-info" title="Permalink to this headline">¶</a></h2>
<p>Expressions used by code generator to describe instructions and isel patterns:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">(implicit</span> <span class="pre">a)</span></tt></dt>
<dd>an implicitly defined physical register.  This tells the dag instruction
selection emitter the input pattern&#8217;s extra definitions matches implicit
physical register definitions.</dd>
</dl>
</div>
<div class="section" id="write-a-backend">
<span id="tablegen-backends"></span><span id="tablegen-backend"></span><span id="id4"></span><h2><a class="toc-backref" href="#id24">TableGen backends</a><a class="headerlink" href="#write-a-backend" title="Permalink to this headline">¶</a></h2>
<p>TODO: How they work, how to write one.  This section should not contain details
about any particular backend, except maybe <tt class="docutils literal"><span class="pre">-print-enums</span></tt> as an example.  This
should highlight the APIs in <tt class="docutils literal"><span class="pre">TableGen/Record.h</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="DebuggingJITedCode.html" title="Debugging JIT-ed Code With GDB"
             >next</a> |</li>
        <li class="right" >
          <a href="SegmentedStacks.html" title="Segmented Stacks in LLVM"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li><a href="subsystems.html" >Subsystem Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, LLVM Project.
      Last updated on 2012-12-21.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>